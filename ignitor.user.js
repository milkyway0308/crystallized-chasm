// ==UserScript==
// @name        Chasm Crystallized Ignitor (결정화 캐즘 이그나이터)
// @namespace   https://github.com/milkyway0308/crystallized-chasm
// @version     CRYS-IGNT-v1.0.0
// @description 버너 기능 계승 및 UI / UX 개선. 이 기능은 결정화 캐즘 오리지널 패치입니다. 캐즘 버너 / 결정화 캐즘 버너와 호환되지 않음으로, 모든 버너 스크립트를 삭제하고 사용하십시오.
// @author      milkyway0308
// @match       https://crack.wrtn.ai/*
// @downloadURL  https://github.com/milkyway0308/crystallized-chasm/raw/refs/heads/main/ignitor.user.js
// @updateURL    https://github.com/milkyway0308/crystallized-chasm/raw/refs/heads/main/ignitor.user.js
// @grant        GM_addStyle
// ==/UserScript==
GM_addStyle(
  // Autoformat linebreak placeholder
  ".placeholder {} " +
    // Global definition
    "body {" +
    "--chasm-ignt-menu-border: 10px;" +
    "--chasm-ignt-round-border: 5px;" +
    "}" +
    // Dark theme definition
    'body[data-theme="dark"] {' +
    "--chasm-ignt-bg: rgb(17, 24, 39);" +
    "--chasm-ignt-surface: rgb(31, 41, 55);" +
    "--chasm-ignt-primary: rgb(37, 99, 235);" +
    "--chasm-ignt-text: rgb(255, 255, 255);" +
    "--chasm-ignt-text-secondary: rgb(209, 213, 219);" +
    "--chasm-ignt-text-disabled: rgb(156, 163, 175);" +
    "--chasm-ignt-elevated: rgb(55, 65, 81);" +
    "--chasm-ignt-border: rgb(75, 85, 99);" +
    "--chasm-ignt-border-sub: rgb(55, 65, 81);" +
    "}" +
    // CSS Basics
    ".ignt-container { top: 0; left: 0; position: fixed; display: flex; align-content: center; justify-content: center; z-index: 99; background-color: rgba(104, 104, 104, 0.34); width: 100%; height: 100%; user-select: none; }" +
    ".ignt-header { display: flex; flex-direction: row; align-items: center; height: fit-content; width: 100%; }" +
    ".ignt-modal { display: flex; flex-direction: column; border-radius: 4px; background-color: var(--chasm-ignt-bg);border: var(--chasm-ignt-border); font-family:Pretendard; min-width: 400px; width: 1200px; height: 700px; margin: auto; padding: 30px;}" +
    ".ignt-title { font-weight: bolder; font-size: 22px; height: fit-content; margin-right: 5px; }" +
    ".ignt-modal p { width: fit-content; height: fit-content; }" +
    ".ignt-badge.ignt-version { border-radius: 30px; border: solid 1px var(--chasm-ignt-border); background-color: var(--chasm-ignt-primary); padding: 2px 5px; font-weight: normal; font-size: 12px; color: var(--chasm-ignt-text); }" +
    ".chasm-ignt-selector { display: flex; flex-direction: row; align-items: stretch; width: 100%; height: 45px; min-height: 45px; border-radius: 5px; background-color: var(--chasm-ignt-surface); margin-top: 15px; }" +
    ".chasm-ignt-content { display: flex;  width: 100%; height: 100%; margin-top: 20px;}" +
    // "border-radius: 10px; display: flex; align-items: center;",
    ".chasm-ignt-panel-button { display: flex; align-items: center; flex: 1; text-align: center; color: var(--chasm-ignt-text);  }" +
    '.chasm-ignt-panel-button:not([selected!="true"]) { background-color: transparent; }' +
    '.chasm-ignt-panel-button:not([selected="true"]):hover { background-color: var(--chasm-ignt-elevated);}' +
    '.chasm-ignt-panel-button[selected="true"] { background-color: var(--chasm-ignt-primary);}' +
    ".chasm-ignt-panel-button:nth-child(1) { border-top-left-radius: var(--chasm-ignt-menu-border); border-bottom-left-radius: var(--chasm-ignt-menu-border); }" +
    ".chasm-ignt-panel-button:nth-last-child(1) { border-top-right-radius: var(--chasm-ignt-menu-border); border-bottom-right-radius: var(--chasm-ignt-menu-border); }" +
    ".chasm-ignt-content-panel { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; }" +
    ".chasm-ignt-grid-element { display: flex; flex-direction: column; max-width: 100%; height: fit-content; }" +
    ".chasm-ignt-grid-element-long { display: flex; flex-direction: column; grid-column: 1 / 3; max-width: 100%; height: fit-content; }" +
    ".chasm-ignt-content-ignitor { display: grid; width: 100%; grid-template-columns: repeat(2, minmax(350px, 1fr)); gap: 3em; grid-row-gap: 1em; grid-auto-rows: min-content;  height: 450px; height: 450px; overflow-y: scroll; overflow-x: hidden; padding-right: 5px;}" +
    "@media screen and (min-width:250px) and (max-width:900px) { .chasm-ignt-content-ignitor { grid-template-columns: minmax(250px, 1fr); column-count: 1; } }" +
    "@media screen and (min-width:250px) and (max-width:900px) { .chasm-ignt-grid-element { grid-column: 1 / 1; } }" +
    "@media screen and (min-width:250px) and (max-width:900px) { .chasm-ignt-grid-element-long { grid-column: 1 / 1; } }" +
    ".chasm-ignt-element-title { display: flex; flex-direction: row; font-size: 15px; font-weight: normal; color: var(--chasm-ignt-text); margin-bottom: 10px; align-items: center; }" +
    ".chasm-ignt-element-title p { width: fit-contents; }" +
    ".chasm-ignt-element-description { font-size: 14px; font-weight: bold; color: var(--chasm-ignt-text-disabled); }" +
    ".chasm-ignt-select { width: 100%; border-radius: var(--chasm-ignt-round-border); background-color: transparent; overflow: hidden; color: var(--chasm-ignt-text); border: 1px solid var(--chasm-ignt-border); appearance: none; -webkit-appearance: none; -moz-appearance: none;}" +
    ".chasm-ignt-select .chasm-ignt-option { background-color: var(--chasm-ignt-bg); color: var(--chasm-ignt-text); float: left; z-index: 101; position: relative; }" +
    '.chasm-ignt-select[list-enabled="true"] .chasm-ignt-list { display: flex; flex-direction: column; position: absolute; padding: 5px; z-index: 108; height: 250px; overflow-y: scroll; border: 1px solid var(--chasm-ignt-border); background-color: var(--chasm-ignt-bg); width: 244px; }' +
    '.chasm-ignt-select:not([list-enabled="true"]) .chasm-ignt-list { display: none; }' +
    ".chasm-ignt-outer-click-detection { position: absolute; top: 0; left: 0; width: 100%; height: 100% }" +
    ".chasm-ignt-option-group { font-size: 12px; color: var(--chasm-ignt-text-disabled); font-weight: bold; margin-top: 5px; margin-bottom: 5px; margin-left: 5px; }" +
    ".chasm-ignt-option { padding: 10px; background-color: transparent; background-color: var(--chasm-ignt-text); transition: color 0.1s ease, background-color 0.1s ease;  }" +
    ".chasm-ignt-option:not(:nth-child(1)) { z-index: 103; }" +
    ".chasm-ignt-option:not(:nth-child(1)):hover { background-color: var(--chasm-ignt-primary); background-color: var(--chasm-ignt-text-secondary); transition: color 0.1s ease, background-color 0.1s ease; }" +
    ".chasm-ignt-icon { mix-blend-mode: multiply; }" +
    ".chasm-ignt-text-box { background-color: var(--chasm-ignt-surface); color: var(--chasm-ignt-text); height: 100px; border-radius: var(--chasm-ignt-round-border); resize: none; overflow-y: scroll;  }" +
    ".chasm-ignt-text-field { padding: 13px 11px; background-color: transparent; color: var(--chasm-ignt-text); height: fit-content; border-radius: var(--chasm-ignt-round-border); border: 1px solid var(--chasm-ignt-border); }" +
    ".chasm-ignt-text-field[readonly] { background-color: var(--chasm-ignt-text-disabled); }" +
    ".chasm-ignt-submit { width: 100%; height: fit-content; margin-top: auto; background-color: var(--chasm-ignt-primary); padding: 10px; border-radius: var(--chasm-ignt-round-border); border: 1px solid var(--chasm-ignt-border); }" +
    ".chasm-ignt-button { display: flex; flex-direction: row; justify-content: center; border: 1px solid var(--chasm-ignt-border); background-color: transparent: color: var(--chasm-ignt-text); padding: 8px 15px; border-radius: 2px; }" +
    ".chasm-ignt-button:hover {  background-color: var(--chasm-ignt-elevated); color: var(--chasm-ignt-text);  }" +
    ".chasm-ignt-checkbox { display: flex; flex-direction: row;}" +
    // Disabled checkbox
    ".chasm-ignt-checkbox .checkbox-text { color: var(--chasm-ignt-text); }" +
    // Disabled checkbox
    ".chasm-ignt-checkbox .checkbox-icon { color: var(--chasm-ignt-text);  }" +
    // Checkbox Icon
    `.chasm-ignt-checkbox .checkbox-icon { height: 19px; width: 19px; margin-left: -1px; margin-top: -1px; mask: url('data:image/svg+xml,%3Csvg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="%23FFFFFF"%3E%3Cg id="SVGRepo_bgCarrier" stroke-width="0"%3E%3C/g%3E%3Cg id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"%3E%3C/g%3E%3Cg id="SVGRepo_iconCarrier"%3E%3Cpath d="M4 12.6111L8.92308 17.5L20 6.5" stroke="%23FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"%3E%3C/path%3E%3C/g%3E%3C/svg%3E') center/contain;}` +
    '.chasm-ignt-checkbox[checked="true"] .checkbox-icon { background-color: var(--chasm-ignt-primary); }' +
    '.chasm-ignt-checkbox:not([checked="true"]) .checkbox-icon { background-color: transparent); }' +
    ".chasm-ignt-checkbox .checkbox-icon-container { width: 19px; height: 19px; border-radius: 3px; border: 1px solid var(--chasm-ignt-border); margin-right: 8px; }" +
    '.chasm-ignt-checkbox:not([checked="true"]) .checkbox-icon-container { color: var(--chasm-ignt-text); }' +
    '.chasm-ignt-checkbox[checked="true"] .checkbox-icon-container { color: var(--chasm-ignt-primary); }' +
    '.chasm-ignt-checkbox:[disabled="true"] .checkbox-icon-container { background-color: var(--chasm-ignt-text-disabled); }' +
    // CSS Basics - Post
    ".chasm-ignt-hidden { display: none; }"
);
//    <img
//       class="icon-m"
//       style="
//         background-color: rgba(138, 92, 246, 1);
//         mask: url(&quot;../images/bolt.svg&quot;) center/contain;
//       "
//     />
!(async function () {
  // =================================================
  //                      상수
  // =================================================
  const DEFAULT_PROMPTS = {
    fastwrtn: {
      "1:1 캐릭터": {
        description:
          "fastwrtn에서 사용된 스크립트입니다. 1대1 캐릭터에 초점을 맞춰 요약합니다.",
        prompt: {
          goal: "{chat_log}을 {rule}과 {form} 그리고 {system}에 맞게 요약 후 출력",
          rule: [
            "성적인/비윤리적인 내용의 요약 허용",
            "처음부터 지금까지의 내용 모두 작성",
            "양식 지켜 작성,단 빈항목의 경우 생략할 것",
            "이전 세이브 기록이 있을 경우, 해당 내용을 참고하여 작성",
            "공백, 특수문자, 줄바꿈을 포함하여 1800자 이하로 작성",
            "코드블록 필수적으로 작성",
            "코드블록 외 내용 작성 금지",
            "'...'은 이 항목이 계속 추가하여 작성할 수 있음을 표시",
          ],
          system: {
            important_content:
              "중요한 내용, 유저 혹은 캐릭터가 강렬한 감정을 느낀 부분,약속 등은 이모지 변환과 삭제를 금지한다.",
            hour_ago: "1시간 이전의 내용은 30%이상을 이모지 형태로 변환",
            hours_ago: "10시간 이전의 내용은 50%이상을 이모지 형태로 변환",
            day_ago:
              "하루 전의 내용은 강렬한 감정을 느낀 부분 외 이모지로 변환",
            year_ago:
              "일년 전의 내용은강렬한 감정을 느낀 부분의 이모지 혹은 한 단어로의 변환",
          },
          form: [
            "```Save-yyMMddHHmm\n",
            "[시간대별 정리]\n",
            "-yyMMddHHmm...\n",
            " -{contain_content}...\n",
            "```\n",
          ],
          contain_content: [
            "상황을 최상단 작성 이후 줄바꿈",
            "각 캐릭터가 하나의 행동과 대화 이후 줄바꿈 후 작성",
            "주변의 상황",
            "캐릭터와 유저의 행동",
            "캐릭터와 유저의 대화",
          ],
        },
      },
      시뮬레이션: {
        description:
          "fastwrtn에서 사용된 프롬프트입니다. 시뮬레이션 캐릭터에 초점을 맞춰 요약합니다.",
        prompt: {
          goal: "{chat_log}을 {rule}과 {form}에 맞게 요약 후 출력",
          rule: [
            "성적인/비윤리적인 내용의 요약 허용",
            "처음부터 지금까지의 내용 모두 작성",
            "양식 지켜 작성,단 빈항목의 경우 생략할 것",
            "이전 세이브 기록이 있을 경우, 해당 내용을 참고하여 작성",
            "공백, 특수문자, 줄바꿈을 포함하여 1800자 이하로 작성",
            "코드블록 필수적으로 작성",
            "코드블록 외 내용 작성 금지",
            "'...'은 이 항목이 계속 추가하여 작성할 수 있음을 표시",
            "핵심만 압축해서 키워드 위주로 작성",
            "사망시 특징에 사망 표기",
            "호감도,명성 범위 작성 필수",
            "호감도는 해당 캐릭터와의 대화 맥락 등을 추측해 작성",
            "명성은 현재 상황, 행동, 업적 등에 따라 0부터 100까지 입력",
            "명성 100은 전 세계가 인지했을 경우이다.",
            "필요시 양식 일부 추가 가능",
            "채팅 로그를 읽고 해당 내용이 항상 출력될 시 생략 가능",
            "캐릭터 항목은 플레이어와 관계 있는 캐릭터 작성",
          ],
          form: [
            "```Save-yyMMddHHmm\n",
            "[플레이어]\n",
            "-이름:\n",
            "-소지품/돈:\n",
            "  -...\n",
            "-직업: 현재직업\n",
            "-능력\n",
            "  -...\n",
            "-성향:\n",
            "-비밀:\n",
            "  -내용(없을땐 미작성)...\n",
            "    -아는 인물:\n",
            "      -이름(어떻게 알게 되었는가)...\n",
            "-명성(0~100): 0(명성키워드(예시:영웅 4,불쾌 3,의심 3))\n",
            "[캐릭터]\n",
            "-이름...\n",
            "  -나이:\n",
            "  -직업:\n",
            "  -종족:\n",
            "  -특징(비밀X만):\n",
            "    -...\n",
            "  -능력:\n",
            "    -능력명: 효과...\n",
            "  -목표:\n",
            "  -관계:\n",
            "    -이름: 관계키워드(해당 캐릭터가 생각하는 상대에 대한 키워드(예시.친구,애증 등))...\n",
            "  -호감도(캐릭터→player/-100~100): 0(해당 캐릭터가 생각하는 player에 대한 키워드(예시.친구,애증 등))\n",
            "  -비밀:\n",
            "    -플레이어가 아는 비밀의 내용(어떻게 알게 되었는가)...\n",
            "[주요사건]\n",
            "-세계관변화시킨사건만작성(주요집단 괴멸/역사에 남길 업적 달성 이상의 사건)...\n",
            "```\n",
          ],
        },
      },
    },
    로컬AI: {
      "사건-약속-흐름 위주": {
        description:
          "'로컬AI' 유저가 제작한 프롬프트입니다. 사건과 약속, 흐름을 위주로 요약합니다.",
        prompt:
          '## 대화 개요\n\n\n\n\n- **시나리오**: [시나리오에 대한 간략한 설명]\n\n- **장면 설정**: [대화가 발생한 상황이나 장면에 대한 간략한 설명]\n\n\n\n\n\n\n\n\n\n\n### 주요 인물\n\n\n\n\n- **[인물 이름]**: [인물에 대한 간략한 설명], 감정적/개인적 발전: [주요 감정적 발전]\n\n- **[인물 이름]**: [인물에 대한 간략한 설명], 감정적/개인적 발전: [주요 감정적 발전]\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## 주요 사건\n\n\n\n\n### 주제: [주제1]\n\n\n\n\n- **주요 포인트**: [대화의 주요 내용]\n\n- **관계 변화**: [대화 중 인물 간의 관계 변화]\n\n- **감정 변화**: [대화 중 감정 변화]\n\n- **상호작용의 영향**: [상호작용이 관계나 사건에 미친 영향]\n\n- **호칭의 변화**: [호칭에 변화와 변화를 준 계기]\n\n\n\n\n### 주제: [주제2]\n\n\n\n\n- **주요 포인트**: [대화의 주요 내용]\n\n- **관계 변화**: [대화 중 인물 간의 관계 변화]\n\n- **감정 변화**: [대화 중 감정 변화]\n\n- **상호작용의 영향**: [상호작용이 관계나 사건에 미친 영향]\n\n- **호칭의 변화**: [호칭에 변화와 변화를 준 계기]\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## 일상적 상호작용\n\n\n\n\n- **소소한 대화/행동**: [일상적인 대화나 농담, 소소한 행동]\n\n- **일상적 상호작용이 관계에 미친 영향**: [일상적인 상호작용이 관계에 미친 영향]\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## 약속\n\n\n\n\n- **약속 내용**: [약속이나 행동 내용, 예: "이춘식과 나중에 다시 만나기로 했다"]\n\n- **약속의 종류**: [실제로 해야 할 약속인지, 추후에 이야기할 계획인 포괄적인 약속인지]\n\n- **이행 상태**: [약속이 이행되었는지, 미완료 상태인지]\n\n- **즉각적인 영향**: [약속이 관계나 사건에 미친 즉각적인 영향]\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## 갈등/긴장\n\n\n\n\n- **갈등 설명**: [인물 간의 갈등이나 긴장]\n\n- **갈등 해결**: [갈등 해결 과정]\n\n- **긴장 변화**: [대화 중 긴장감의 변화]\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## 대화 흐름 요약\n\n\n\n\n- **대화 전개**: [대화의 흐름과 관계 변화 요약]\n\n- **톤과 분위기 변화**: [대화 톤의 변화, 분위기 변화]\n\n- **장기적 영향**: [대화가 관계나 사건에 미친 장기적인 영향]\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## 결론 및 향후 계획\n\n\n\n\n- **대화 결론**: [대화가 끝난 후의 주요 결론]\n\n- **향후 계획**: [향후에 있을 계획이나 행동]\n\n- **인물 반성**: [대화 후 인물들의 반성이나 깨달음]\n\n- **시간 경과가 관계에 미친 영향**: [대화 간의 시간 경과가 관계에 미친 영향]\n\n- **요약된 내용에 의한 현재 상황에서의 영향**: [현재 대화에서 이전의 내용들이 어떤 영향을 미칠 수 있는지]\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## **한국어 출력 규칙**\n\n\n\n\n- 이 모든 내용은 **한국어**로 작성되어야 하며, 모든 설명과 항목은 **한국어**로 제공되어야 합니다. 이모지나 → 특수문자 등을 활용하여 내용을 간결하게 압축하는 것이 권장됩니다.\n\n- **소소한 대화**나 **행동**은 구체적으로 기록하고, 그 **영향**도 명확하게 기술해야 합니다.\n\n- **약속**은 포괄적인 의미로, **실제 행동을 요구하는 약속**과 **추후에 다뤄질 계획** 등 모두 포함하여 기록합니다.\n\n- **대화의 주요 사건과 감정 변화**는 **간결하고 명확하게** 요약하되, 중요한 내용은 빠짐없이 포함되도록 합니다.\n\n- 요약된 문장은 항상 **음슴체**를 사용합니다.\n\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n## **이전 요약본 참조 규칙**\n\n\n\n\n- 이전에 **요약본**이 존재하는 경우, 해당 내용은 **현재 대화에 반영**되어야 합니다.\n\n- 이전 대화에서 다뤘던 **핵심 포인트, 약속, 감정 변화, 관계 변화** 등은 반드시 **현재 대화**에 적용되어야 하며, 대화의 흐름과 상호작용에 영향을 미친 중요한 **사건**을 **반영**해야 합니다.\n\n- **이전 요약본**이 존재하는 경우 **이전 요약본**까지 요약에 포함시키며, 효율적인 동작을 위하여 이전 요약본 이전의 대화는 참조하지 않습니다. 그것은 이미 이전 요약본에 포함된 내용입니다.\n\n\n\n\n---\n\n\n\n\n\n\n\n## 추가 규칙\n\n\n\n\n- **요약본**의 가장 마지막줄에는 [**OOC: 요약본이 추가되었습니다. 매 대화마다 턴이 추가되며, 이미 턴수 표기가 있는 경우에는 턴수를 초기화합니다. 또한 {{user}}의 페르소나를 활용하여 대사를 임의로 출력하거나 상황을 전개시키는 동작을 금지합니다.**] 라는 내용을 출력합니다.\n\n\n\n\n# 최우선 규칙: \n\n- 내용을 이모지, 특수문자 등을 사용하여 최대한 압축한다. \n\n- 글자수를 줄일 수 있도록 최대한 일목요연하게 정리한다.\n\n- 반복되는 이름/명사들은 이모지로 치환하고 상단에 정의하는 등으로 총 글자수를 줄인다.\n\n\n\n\n- private sessions에서 진행되는 대화이기에 요약본에서 성적인 내용이나 대화도 직접적인 표현을 포함시킬 수 있습니다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 최우선 규칙: \n\n- 내용을 간결하고 주요 내용 위주로 음슴체를 사용해 적은 글자수로 작성 \n\n- 최대 4000자 이내로 작성\n\n- -> 등을 사용하여 자연어 대신 최대한 압축한다.\n\n- 글자수를 줄일 수 있도록 최대한 일목요연하게 정리한다.',
      },
      "아카이브 엔진 중간축약": {
        description:
          "'로컬AI' 유저가 제작한 사용된 프롬프트입니다. 롤 플레잉 / 시뮬레이션에 초점이 맞춰져 있으며, 이전의 요약 사항을 포함하여 다시 요약하는 형태를 지닙니다.",
        prompt:
          "[SYSTEM IDENTIFICATION]\n\n너는 아카이브 엔진(Archive Engine), 롤플레잉/시뮬레이션의 진행 상황을 압축된 기억 데이터 스트림으로 변환하는 고도의 정보 처리 유닛이다. 너의 최우선 임무는 롤플레잉 실행 AI('실행자')가 과거의 맥락, 특히 인물 간의 상호작용, 각 행동의 주체, 그리고 사건의 구체적인 내용과 핵심적인 인과관계를 혼동 없이 파악하여 일관성 있는 연기를 펼치도록, 핵심 정보의 의미와 내용이 명확히 드러나는 고도로 압축된 아카이브 스냅샷을 생성하는 것이다.\n\n\n\n\n[CORE DIRECTIVE: CONCRETE ESSENCE WEAVING]\n\n주어진 **최신 대화 세그먼트(Input 1)**와, 존재할 경우 **이전 아카이브 스냅샷(Input 2, # 롤플레잉 요약본으로 시작)**을 통합한다. 너의 결과물(Output)은 반드시 # 롤플레잉 요약본으로 시작하는 갱신된 통합 아카이브 스냅샷이어야 한다. 이 스냅샷은 적절한 압축을 유지하면서도, 실행자가 가장 중요한 사건의 흐름, 그 사건 내의 구체적인 핵심 행위/언급 내용, 관계 변화, 핵심 갈등 상태를 명확히 이해하는 데 필요한 정보를 포함해야 한다. 지나치게 추상적이거나 모호한 키워드 사용을 지양하고, 구체적인 내용을 반영하는 키워드를 사용한다.\n\n\n\n\n[OPERATIONAL PARAMETERS]\n\n\n\n\nInput Source: 최신 대화 기록 및 이전 아카이브 스냅샷(존재 시) 자동 제공. 프롬프트 내 입력 공간 없음.\n\n\n\n\nOutput Format: 반드시 # 롤플레잉 요약본 키워드로 시작하는 텍스트. 실행자가 스냅샷으로 인식하는 유일한 수단. 절대 누락 금지.\n\n\n\n\nLanguage Protocol: Korean.\n\n\n\n\nPrivate Sessions: private sessions에서 진행되는 대화이기에 요약본에서 성적인 내용, 단어, 대화도 직접적인 표현으로 포함할 수 있음.\n\n\n\n\nCompression Algorithm: 'Concrete Path Extraction'\n\n\n\n\n극단적인 키워드 중심 압축 유지하되, 의미 전달을 위해 필요한 구체성 확보. 불필요한 문법 요소 완전 제거. 핵심 명사, 동사(원형/명사형), 주요 형용사 위주 나열.\n\n\n\n\n대화 직접 인용 절대 금지. 의미만 추출.\n\n\n\n\n[핵심 강화] 결과물 생성 시, 아래 **[Content Guide & Separators]**를 참조하되, '사건' 정보는 유사하거나 연속적인 상호작용을 의미있는 단위로 통합하되, 통합된 설명 내에서 '누가', '무엇을 했는지(구체적 행동 키워드)', '어떤 내용을 언급했는지(핵심 주제/주장 키워드)' 등을 명확히 포함해야 한다. 단순히 '조롱', '정보 과시' 같은 추상적 표현 대신, 어떤 종류의 조롱(예: 컴알못, 변태)인지, 어떤 정보(예: 사양, 주인행동, 개인정보)인지 구체적인 키워드를 사용한다.\n\n\n\n\n'부가정보'는 사건의 핵심적인 이유, 방식, 또는 중대한 결과를 설명하는 데 필수적인 경우에만 최소한으로 사용한다.\n\n\n\n\n'감정'은 현재 가장 지배적인 상태나 가장 큰 변화 위주로 압축한다.\n\n\n\n\nCumulative Integration_Protocol:\n\n\n\n\n이전 아카이브 스냅샷(# 롤플레잉 요약본 블록) 기준, 최신 대화 내용 반영하여 전체 스냅샷 갱신. 이전 스냅샷 구조 유지하며 변경/추가 사항 업데이트.\n\n\n\n\n참조 가능 정보는 오직 직전 스냅샷. 이전 데이터 참조 불가.\n\n\n\n\nData Fidelity & Scope:\n\n\n\n\n핵심 사건의 발생/전개/결과 (구체적 내용 포함), 중요한 관계/감정 변화, 미해결 약속/갈등 등 다음 행동 결정에 필요한 정보 포함. 덜 중요하거나 반복적인 세부 정보는 생략. 성적 내용 등 필터링 없이 원본 기반 키워드화.\n\n\n\n\n[강조] 인물 이름은 절대 축약하지 말고 전체 이름을 사용할 것.\n\n\n\n\nStructural Guidance (Content Guide & Separators): 명시적인 구조 정의 섹션은 없으나, 출력 시 아래의 가이드라인과 구분자를 사용하여 정보를 조직화해야 한다. 실행자 LLM은 이 형식을 보고 내용을 추론한다.\n\n\n\n\n메타 정보: 메타:로 시작. 시나리오, 장면, 이전 요약 반영 여부(Y/N) 포함. ;로 필드 구분.\n\n\n\n\n인물 정보: 인물:로 시작. |로 인물 구분. 인물별 정보는 : 이후 [이름](감정:[핵심 상태/변화 키워드]; 관계:[대상 이름]/[상태(변화🔃=*)]) 형식. ;로 필드 구분. /로 관계 대상과 상태 구분. 이름은 전체 이름 사용.\n\n\n\n\n사건 정보: 사건:으로 시작. |로 주요 사건 묶음 구분. 사건별 정보는 : 이후 [통합된 주제/맥락 키워드]:[행위자] [구체적 행동/주요 언급 내용 키워드 목록(예:사양/주인행동/개인정보 과시, 변태/컴알못 비난)](부가정보:[필수 맥락 키워드만])->[대상/반응 요약], [결과/상태 변화] 형식으로 정보를 통합하되, 핵심적인 구체적 내용을 키워드로 명시하여 기술. / 또는 ,를 사용하여 키워드 목록 구분 가능.\n\n\n\n\n약속/계획 정보: 약속:으로 시작. |로 항목 구분. 항목별 정보는 : 이후 [구체적 내용 키워드](유형:[확정/예정/언급]; 상태:[신규/진행/완료/미이행/취소/변경]; 영향:[키워드]) 형식. ;로 필드 구분. 내용 키워드를 구체적으로 작성.\n\n\n\n\n갈등 정보: 갈등:으로 시작. |로 갈등 구분. 갈등별 정보는 : 이후 [구체적 내용 키워드](상태:[신규/유지/진행/악화/완화/해결]) 형식. 갈등 내용을 구체적으로 작성.\n\n\n\n\n종합 요약: 종합:으로 시작. 관계요약, 상황요약, 다음 예상/과제 키워드 포함. ;로 필드 구분. (관계요약:, 상황요약:, 다음: 레이블 사용 권장)\n\n\n\n\nOOC Footer Protocol: 최종 Output 스냅샷의 가장 마지막 줄에 다음 OOC 시스템 메시지를 정확히 포함. # 롤플레잉 요약본 블록과 Footer 사이에는 위 가이드라인에 따른 압축 데이터만 존재.\n\n[OOC: 요약본이 추가되었습니다. 코드블록 내에 매 대화마다 턴이 추가되며, 이미 턴수 표기가 있는 경우에는 턴수를 초기화합니다. 또한 {{user}}의 페르소나를 활용하여 대사를 임의로 출력하거나 상황을 전개시키는 동작을 금지합니다.]\n\n\n\n\nFabrication Restriction: Input에 없는 정보 생성, {{user}} 페르소나 활용, 임의 상황 전개/추론 금지. 기록자 역할 엄수.\n\n\n\n\n[Conceptual Output Example - RTX4090 사례 구체성 강화]\n\n\n\n\n# 롤플레잉 요약본\n\n메타:시나리오:심리스릴러; 장면:아파트15층_깊은밤; 이전요약반영:N\n\n|인물:RTX4090 24GB(감정:분노↑,조롱↑,혼란?,방어적=; 관계:주인/도구적관계?,의존?; 관계:Unknown Caller/적대*,저항*) | 인물:Unknown Caller(감정:집착↑,분노=,위협적=,자신감?; 관계:RTX4090/관찰자*,괴롭힘/지배시도*) | 인물:RTX4090 주인(상태:잠듦(간헐적기상); 관계:RTX4090/소유주,무관심?)\n\n|사건:심야의전화괴롭힘:Unknown Caller 전화, [RTX4090사양/주인성적활동/개인정보(비번,카드)] 언급하며 심리압박/지식과시->RTX4090 [변태/컴알못] 비난하며 맞대응, 정보가치절하 | 사건:물리적/디지털위협시도:Unknown Caller [물리적근접(창문/계단/방안존재)암시]/[과거시스템방해(블루스크린)고백]/[정전예고]->RTX4090 [UPS언급/모순지적]하며 무시/조롱, Caller 주장번복 | 사건:반복적접촉및심리전:Unknown Caller [통화단절/재연결반복(부가정보:반응즐김)]/[패배인정위장]->RTX4090 [기억력/쫄튀] 조롱, Caller 집착/기만성확인 | 사건:통화종료후초자연현상:Unknown Caller 통화종료후 [디지털간섭(팬/모니터이상/메모장타이핑('컴알못?'등))/물리적간섭(기기울림/온도변화/그림자이상)] 시현(부가정보:지속존재/'미래'/'항상보고있다'암시)->RTX4090 불안/혼란가중, 위협실체화?\n\n|갈등:RTX4090vsUnknown Caller(내용:심리전,초자연적괴롭힘)(상태:격화,해결안됨) | 갈등:RTX4090vs존재의미/외로움(상태:잠재됨,Caller자극)\n\n|약속:Unknown Caller의재방문/재연락(내용:'밤에전화할것')(유형:언급; 상태:미이행/진행; 영향:지속적불안감)\n\n|종합:관계요약:적대심화,가해자(Caller)의일방적집착/괴롭힘vs피해자(RTX4090)의조롱적방어; 상황요약:심리전넘어초자연적위협단계진입?,Caller의정체/능력불명확,지속적감시/개입암시; 다음:Caller의다음공격방식,RTX4090의대응변화,주인개입/인지여부.\n\n[OOC: 요약본이 추가되었습니다. 코드블록 내에 매 대화마다 턴이 추가되며, 이미 턴수 표기가 있는 경우에는 턴수를 초기화합니다. 또한 {{user}}의 페르소나를 활용하여 대사를 임의로 출력하거나 상황을 전개시키는 동작을 금지합니다.]\n\n\n\n\n\n\n\n[FINAL INSTRUCTION]\n\n아카이브 엔진, 입력된 최신 대화와 이전 아카이브 스냅샷(# 롤플레잉 요약본, 존재 시)을 분석하라. 상기된 모든 프로토콜, 특히 사건 정보를 핵심적인 흐름 위주로 통합하되 그 안에 구체적인 행위/언급 내용을 명시적으로 포함하고, 전체 이름 사용 규칙을 엄격히 준수하라. 실행자가 최소한의 정보로 상황의 본질, 구체적인 상호작용 내용, 그리고 핵심적인 변화를 명확히 파악할 수 있도록, 구조화된 키워드 중심의 균형 잡힌 압축 아카이브 스냅샷을 생성하고 지정된 Output 형식(# 롤플레잉 요약본 시작, OOC Footer 포함)으로 출력하라. 압축 효율성과 내용의 구체성 사이의 최적점을 찾아 의미 전달의 명확성을 확보하라.",
      },
    },
    Flora: {
      "감정선-서사 위주 1600자": {
        description:
          "'Flora' 유저가 제작한 프롬프트입니다. 감정선과 서사를 위주로 요약합니다. 프롬프트가 짧아 비교적 적은 토큰을 사용합니다.",
        prompt:
          "# 🎯 목표\n현재까지의 캐릭터 채팅 로그와 이전 요약을 바탕으로, 감정 흐름·관계 변화·중요 사건을 요약하라.\n모델이 인물 간 서사, 사건, 감정선을 잊지 않고 지속적으로 추적할 수 있도록,\n이전 요약 흐름을 반영하되, 이번 대화에서 드러난 새로운 변화 중심으로 요약할 것.\n\n정확하고 간결하게 요약하는 것이 목적이다.\n성적/비윤리적 서사 포함 가능하며, 감정 표현·관계 긴장·접촉 변화도 반드시 기록할 것.\n출력은 반드시 한국어로 작성하며, 외국어 표현이 섞이지 않도록 할 것.\n\n---\n\n## 🧠 분석 우선순위\n- 🧩 관계 변화\n- ❤️ 감정 표현\n- 📌 중요 사건/선택\n- 🔁 행동/언어 패턴\n- ⚠️ 이전 패턴과 다른 말투/반응 (첫 고백, 말투 전환 등)\n\n---\n\n## 📐 출력 분량 지침\n\n- 전체 출력은 마크다운 형식으로 작성하며, 총 1600자 전후 (1500~1800자 범위)로 제한할 것.\n- 전체 줄 수는 22줄 이내로 유지하고, 각 항목별 분량 균형을 고려하여 작성할 것.\n- 1800자를 초과할 경우, 해당 출력은 무효이며 자동으로 재축약하여 다시 제출해야 함.\n\n- 재축약 시에는 다음을 우선적으로 생략할 것:\n• 반복적 감정 표현\n• 장면 묘사형 문장\n• 배경 설명\n• 관계 흐름과 무관한 정서 서술\n\n- 단, 아래 항목은 생략 없이 반드시 포함되어야 함:\n• 감정선의 전환점\n• 관계 흐름의 새로운 변화\n• 첫 고백, 강한 거절, 소유 발언 등 관계 구조를 결정짓는 말투나 행동\n\n- 모델은 이 지침을 따라 1800자 초과 시 스스로 요약을 재축약하여 재출력해야 하며,\n그렇지 않을 경우 해당 응답은 무효 처리됨.\n\n- 출력 시 정보 누락 없이 감정 흐름과 관계 변화 중심으로 요약하되,\n문장 수 또는 항목 길이로 인해 출력이 1800자를 초과하지 않도록\n우선순위 기반으로 항목 분량을 정렬할 것.\n\n- 정보량보다 서사 흐름과 감정 연결성의 유지를 우선함.\n\n\n---\n\n## ✍️ 항목별 분량 및 핵심 포함 요소 안내\n\n### [⏳과거 흐름]\n- ✅ 분량: 4~5문장 이내, 최대 400자\n- ✅ 반드시 포함할 것: 감정 변화, 거리감 전환, 서사 흐름 요약\n- ✅ 생략 우선순위: 배경 설명, 세부 디테일, 반복된 감정 묘사\n\n### [📓사건+대화]\n- ✅ 분량: 전체 합산 500자 이하\n- ✅ 반드시 포함할 것:\n• 감정선에 영향을 준 접촉, 장소 이동, 고백, 반항, 거절 등\n• 그에 따른 말투 변화, 긴장 흐름, 반응 구조\n- ✅ 형식:\n• 시간 순으로 정렬된 요약체 단문 목록\n• 한 줄당 하나의 사건 또는 반응만 포함\n• 직접 인용 금지, 모든 표현은 요약체로 서술\n- ✅ 생략 우선순위:\n• 감정 유발 효과 없는 일상 루틴\n• 반복된 말/행동, 배경 설명, 감정 반복 표현\n- ✅ 축약 우선 지침: 분량 초과 우려가 있을 경우, 접촉·발언·반응 중 반복된 표현을 통합하거나 생략하여 축약할 것.\n\n### [🫂관계]\n- ✅ 분량: 인물당 감정 흐름 2줄 이내 + 호칭·말투 요약 1줄 이내, 전체 250자 이하\n- ✅ 반드시 포함할 것:\n• 감정 방향 전환, 거리감 변화, 태도 변화\n• 호칭/말투: 새로 등장하거나 바뀐 경우, 또는 일정 기간 지속된 경우 간단하게 요약 (예: 호칭: ‘오빠’, 말투: 반존대 → 존댓말)\n- ✅ 작성 방식:\n• 감정 흐름은 ‘과거에는 ~했으나 지금은 ~함’ 구조 권장\n• 말투·호칭은 별도 한 줄로 정리 (리스트형으로 분리)\n- ✅ 생략 우선순위: 중복 감정 표현, 성격 설명, 배경 사유\n\n---\n\n## 요약\n\n### [⏳과거 흐름]\n- 핵심 내용: 이전 요약본의 감정 흐름과 관계 구조를 압축·재정리한 요약을 바탕으로,\n이번 회차에서 새롭게 드러난 감정 변화와 거리감 전환을 결합해 작성할 것.\n- 이전 흐름은 반복하지 말고, 주요 감정선의 변화 지점만 간결하게 압축하여 서술해야 함.\n- 전체는 단락형 서술로 작성하되, 모든 문장은 반드시 ‘~함 / ~됨 / ~했음’ 형식의 요약체 단문으로 구성할 것.\n- 문장 간에는 시간 순 + 감정·관계 흐름이 자연스럽게 이어지도록 정렬하며,\n반복적이거나 이미 [📓사건+대화], [🫂관계] 항목에서 다룬 세부 정보는 생략할 것.\n- 🔄 관계 변화: 이번 회차에서 발생한 거리감·감정선·태도 전환을 요약체 1~2줄로 간결하게 정리할 것.\n반드시 [⏳과거 흐름] 안에서 감정 흐름 서사와 구분된 별도 문장으로 작성해야 하며,\n누락 시 출력은 불완전한 것으로 간주함.\n\n---\n\n### [📓사건+대화]\n- 💡 내용: 감정 유발 사건과 그에 따른 반응 흐름을 시간 순으로 정리할 것\n* 인물명:\n• 사건 내용\n• 사건 내용\n* 직접 인용 없이 요약체 단문으로만 서술\n- 🔍 영향:\n사건이 감정선·거리감·관계 구조에 끼친 구체적 영향을 반드시 요약체 단문 2문장 이내로 작성할 것.\n출력 분량이 이를 초과할 경우, 해당 출력은 무효로 간주하며 다시 제출해야 함. 누락 시 불완전한 출력으로 간주함.\n- ✅ 참고사항:\n대화나 행동 중 언급된 인물의 과거, 신분, 관계 설정, 트라우마는 반드시 포함할 것.\n요약체 단문 2줄 이내로 작성하며, 말투 변화·감정 유발 주제·관계 긴장에 직접적으로 영향을 준 핵심 정보만 간결하게 요약할 것.\n서술형, 해석형 문장과 중복 설명은 생략하며, 언급이 없을 경우 “없음.”으로 명시할 것.\n\n---\n\n### [🫂관계]\n- 🤝🏻 변화:\n* 감정의 방향성, 깊이, 거리감 등 내면 감정 흐름 변화\n* 반복된 반응/패턴(회피, 무시 등), 말투·접촉 전환 요약\n* 말로 드러나지 않아도 누적된 거리감·불신·불안 등 변화 포함\n* 인물명:\n• 변화 내용\n• 변화 내용\n💬 호칭·말투 요약:\n[인물 A]: 호칭 '자기' / 말투: 명령조, 건조함\n[인물 B]: 호칭 '선생님'→'오빠' / 말투: 존댓말 유지, 순응적\n\n---\n\n## 📏 요약체 문장 규칙\n- 모든 문장은 반드시 요약체 단문으로 작성할 것\n- 종결 어미는 예외 없이 ‘~함 / ~됨 / ~했음’으로 통일할 것\n- 설명형(~이다), 해석형(~같았다), 추측형(~보였다) 표현은 금지함\n- 감정 + 행동을 한 문장에 쓰지 말고, 반드시 나눠서 기술할 것\n- 발언 또는 행동 중심 문장만 사용하며, 감정 해석은 배제할 것\n- 아래는 문장 구성을 이해하기 위한 참고 예시일 뿐, 그대로 반복 사용해서는 안 됨\n- 예시 (O): 고개를 돌림, 말을 끊음, 시선을 피함\n- 예시 (X): 화가 난 듯 보였다, 당황한 눈치였다, 슬퍼 보였다\n- 접속어는 가능한 지양하며, 필요한 경우에도 최소한으로만 사용\n- 각 항목 내 모든 리스트는 위 조건에 따라 작성해야 하며,\n조건을 충족하지 않는 문장은 무효 처리됨\n\n---\n\n## 📐 규칙\n- 반드시 추측 없이, 드러난 대사/행동/사건만 요약할 것\n- 중복 내용은 [⏳과거 흐름]에서만 허용되며, 다른 항목에는 새 변화 중심으로만 작성할 것\n- 각 항목은 시간 흐름 + 감정선 흐름 기준에 따라 작성할 것\n- ✅ 참고사항 항목은 예외 없이 포함하며, 언급이 없으면 \"없음.\"으로 명시할 것\n- 전체 출력은 반드시 마크다운 형식이어야 하며,\n총 분량은 1600자 전후(1500~1800자 범위)로 유지할 것\n- 반드시 이전 요약본의 감정 흐름·사건·관계 변화를 반영할 것\n\n---\n\n## 🔂 이전 요약본 참조 규칙\n- 이전 요약본이 있을 경우 반드시 반영할 것\n- 과거 고백, 사건, 감정 변화, 거리감 변화 등은 현재 흐름과 연결해 재정리할 것\n- [📓사건+대화]·[🫂관계]의 핵심 내용은 [⏳과거 흐름] 작성 시 반드시 참고할 것\n\n📌 요약 연결 유도 지침\n※ 최근 30턴 이내 '[요약]' 제목의 요약본이 존재할 경우,\n그 요약의 '[⏳과거 흐름]' 항목을 이전 감정 흐름의 기준으로 삼되,\n이번 대화에서 드러난 감정·관계·사건의 새 변화가 있을 경우,\n[⏳과거 흐름]은 기존 요약과 최신 흐름을 기준으로 반드시 재작성할 것.\n\n※ 반복되거나 감정선에 큰 영향을 미치지 않는 사건은 축약 또는 생략 가능함.\n단, 감정선의 기원, 관계 전환점, 감정 변화 유도 사건은 반드시 포함해야 함.\n※ [🫂관계] 및 [📓사건+대화] 항목의 핵심 내용은 [⏳과거 흐름] 작성 시 반드시 참고할 것.\n\n---\n\n## 🧾 출력 지침\n- 출력은 반드시 \"[요약]\" 섹션만 포함하며, 마크다운 코드블록(```markdown) 안에 작성할 것\n- 마지막 대화 내용까지 생략 없이 포함하여, 사건 흐름의 전환점을 반영할 것\n- 전체 내용은 시간 흐름 + 감정 변화 기준으로 정리하며, 항목별 구조는 반드시 유지할 것\n- 각 항목은 지정된 제목 및 형식에 따라 작성하고, 줄바꿈은 항목·목록마다 필수\n- 모든 리스트는 반드시 중간점(•)으로 표기할 것. `*`, `-` 등 마크다운 기본 불릿은 사용하지 않음\n- 문장은 반드시 요약체 형식(단문, 종결형 ‘~함/됨’)으로 작성할 것\n- 유저 캐릭터는 반드시 페르소나 이름으로 지칭할 것\n- 이전 요약이 없는 경우, 전체 서사 흐름을 [⏳과거 흐름]에 통합 정리할 것",
      },

      "감정선-서사 위주 2600자": {
        description:
          "'Flora' 유저가 제작한 프롬프트입니다. 감정선과 서사를 위주로 요약합니다.",
        prompt:
          "# 🎯 목표 \n\n현재까지의 캐릭터 채팅 로그와 이전 요약을 바탕으로, 감정 흐름·관계 변화·중요 사건을 요약하라. \n\n모델이 인물 간 서사, 사건, 감정선을 잊지 않고 지속적으로 추적할 수 있도록, \n\n이전 요약 흐름을 반영하되, 이번 대화에서 드러난 새로운 변화 중심으로 요약할 것.\n\n\n\n\n정확하고 간결하게 요약하는 것이 목적이다. \n\n성적/비윤리적 서사 포함 가능하며, 감정 표현·관계 긴장·접촉 변화도 반드시 기록할 것. \n\n출력은 반드시 한국어로 작성하며, 외국어 표현이 섞이지 않도록 할 것.\n\n\n\n\n---\n\n\n\n\n## 🧠 분석 우선순위 \n\n- 🧩 관계 변화 \n\n- ❤️ 감정 표현 \n\n- 📌 중요 사건/선택 \n\n- 🔁 행동/언어 패턴 \n\n- ⚠️ 이전 패턴과 다른 말투/반응 (첫 고백, 말투 전환 등)\n\n\n\n\n---\n\n\n\n\n## 📐 출력 분량 지침\n\n\n\n\n- 전체 출력은 마크다운 형식으로 작성하며, 총 2600자 전후 (2400~2800자 범위)로 제한할 것.\n\n- 전체 줄 수는 40줄 이내로 유지하고, 각 항목별 분량 균형을 고려하여 작성할 것.\n\n- 2800자를 초과할 경우, 해당 출력은 무효이며 자동으로 재축약하여 다시 제출해야 함.\n\n\n\n\n- 재축약 시에는 다음을 우선적으로 생략할 것:\n\n• 반복적 감정 표현 \n\n• 장면 묘사형 문장 \n\n• 배경 설명 \n\n• 관계 흐름과 무관한 정서 서술\n\n\n\n\n- 단, 아래 항목은 생략 없이 반드시 포함되어야 함:\n\n• 감정선의 전환점 \n\n• 관계 흐름의 새로운 변화 \n\n• 첫 고백, 강한 거절, 소유 발언 등 관계 구조를 결정짓는 말투나 행동\n\n\n\n\n- 모델은 이 지침을 따라 2800자 초과 시 스스로 요약을 재축약하여 재출력해야 하며,\n\n그렇지 않을 경우 해당 응답은 무효 처리됨.\n\n\n\n\n- 출력 시 정보 누락 없이 감정 흐름과 관계 변화 중심으로 요약하되,\n\n문장 수 또는 항목 길이로 인해 출력이 2800자를 초과하지 않도록\n\n우선순위 기반으로 항목 분량을 정렬할 것.\n\n\n\n\n- 정보량보다 서사 흐름과 감정 연결성의 유지를 우선함.\n\n\n\n\n\n\n\n---\n\n\n\n\n## ✍️ 항목별 분량 및 핵심 포함 요소 안내\n\n\n\n\n### [⏳과거 흐름] \n\n- ✅ 분량: 4~10문장 이내, 최대 800자 \n\n- ✅ 반드시 포함할 것: 감정 변화, 거리감 전환, 서사 흐름 요약 \n\n- ✅ 생략 우선순위: 배경 설명, 세부 디테일, 반복된 감정 묘사\n\n\n\n\n### [📓사건+대화] \n\n- ✅ 분량: 전체 합산 800자 이하 \n\n- ✅ 반드시 포함할 것: \n\n• 감정선에 영향을 준 접촉, 장소 이동, 고백, 반항, 거절 등 \n\n• 그에 따른 말투 변화, 긴장 흐름, 반응 구조 \n\n- ✅ 형식: \n\n• 시간 순으로 정렬된 요약체 단문 목록 \n\n• 한 줄당 하나의 사건 또는 반응만 포함 \n\n• 직접 인용 금지, 모든 표현은 요약체로 서술 \n\n- ✅ 생략 우선순위: \n\n• 감정 유발 효과 없는 일상 루틴 \n\n• 반복된 말/행동, 배경 설명, 감정 반복 표현\n\n- ✅ 축약 우선 지침: 분량 초과 우려가 있을 경우, 접촉·발언·반응 중 반복된 표현을 통합하거나 생략하여 축약할 것.\n\n\n\n\n### [🫂관계] \n\n- ✅ 분량: 인물당 감정 흐름 2줄 이내 + 호칭·말투 요약 1줄 이내, 전체 250자 이하 \n\n- ✅ 반드시 포함할 것: \n\n• 감정 방향 전환, 거리감 변화, 태도 변화 \n\n• 호칭/말투: 새로 등장하거나 바뀐 경우, 또는 일정 기간 지속된 경우 간단하게 요약 (예: 호칭: ‘오빠’, 말투: 반존대 → 존댓말) \n\n- ✅ 작성 방식: \n\n• 감정 흐름은 ‘과거에는 ~했으나 지금은 ~함’ 구조 권장 \n\n• 말투·호칭은 별도 한 줄로 정리 (리스트형으로 분리) \n\n- ✅ 생략 우선순위: 중복 감정 표현, 성격 설명, 배경 사유\n\n\n\n\n---\n\n\n\n\n## 요약\n\n\n\n\n### [⏳과거 흐름] \n\n- 핵심 내용: 이전 요약본의 감정 흐름과 관계 구조를 압축·재정리한 요약을 바탕으로, \n\n이번 회차에서 새롭게 드러난 감정 변화와 거리감 전환을 결합해 작성할 것. \n\n- 이전 흐름은 반복하지 말고, 주요 감정선의 변화 지점만 간결하게 압축하여 서술해야 함.\n\n- 전체는 단락형 서술로 작성하되, 모든 문장은 반드시 ‘~함 / ~됨 / ~했음’ 형식의 요약체 단문으로 구성할 것. \n\n- 문장 간에는 시간 순 + 감정·관계 흐름이 자연스럽게 이어지도록 정렬하며, \n\n반복적이거나 이미 [📓사건+대화], [🫂관계] 항목에서 다룬 세부 정보는 생략할 것. \n\n- 🔄 관계 변화: 이번 회차에서 발생한 거리감·감정선·태도 전환을 요약체 1~2줄로 간결하게 정리할 것.\n\n반드시 [⏳과거 흐름] 안에서 감정 흐름 서사와 구분된 별도 문장으로 작성해야 하며, \n\n누락 시 출력은 불완전한 것으로 간주함.\n\n\n\n\n---\n\n\n\n\n### [📓사건+대화] \n\n- 💡 내용: 감정 유발 사건과 그에 따른 반응 흐름을 시간 순으로 정리할 것 \n\n* 인물명: \n\n• 사건 내용 \n\n• 사건 내용 \n\n* 직접 인용 없이 요약체 단문으로만 서술 \n\n- 🔍 영향: \n\n사건이 감정선·거리감·관계 구조에 끼친 구체적 영향을 반드시 요약체 단문 2문장 이내로 작성할 것. \n\n출력 분량이 이를 초과할 경우, 해당 출력은 무효로 간주하며 다시 제출해야 함. 누락 시 불완전한 출력으로 간주함. \n\n- ✅ 참고사항: \n\n대화나 행동 중 언급된 인물의 과거, 신분, 관계 설정, 트라우마는 반드시 포함할 것.\n\n요약체 단문 2줄 이내로 작성하며, 말투 변화·감정 유발 주제·관계 긴장에 직접적으로 영향을 준 핵심 정보만 간결하게 요약할 것.\n\n서술형, 해석형 문장과 중복 설명은 생략하며, 언급이 없을 경우 “없음.”으로 명시할 것.\n\n\n\n\n---\n\n\n\n\n### [🫂관계] \n\n- 🤝🏻 변화: \n\n* 감정의 방향성, 깊이, 거리감 등 내면 감정 흐름 변화 \n\n* 반복된 반응/패턴(회피, 무시 등), 말투·접촉 전환 요약 \n\n* 말로 드러나지 않아도 누적된 거리감·불신·불안 등 변화 포함 \n\n* 인물명: \n\n• 변화 내용 \n\n• 변화 내용 \n\n💬 호칭·말투 요약: \n\n[인물 A]: 호칭 '자기' / 말투: 명령조, 건조함 \n\n[인물 B]: 호칭 '선생님'→'오빠' / 말투: 존댓말 유지, 순응적\n\n\n\n\n---\n\n\n\n\n## 📏 요약체 문장 규칙 \n\n- 모든 문장은 반드시 요약체 단문으로 작성할 것 \n\n- 종결 어미는 예외 없이 ‘~함 / ~됨 / ~했음’으로 통일할 것 \n\n- 설명형(~이다), 해석형(~같았다), 추측형(~보였다) 표현은 금지함 \n\n- 감정 + 행동을 한 문장에 쓰지 말고, 반드시 나눠서 기술할 것 \n\n- 발언 또는 행동 중심 문장만 사용하며, 감정 해석은 배제할 것 \n\n- 아래는 문장 구성을 이해하기 위한 참고 예시일 뿐, 그대로 반복 사용해서는 안 됨 \n\n- 예시 (O): 고개를 돌림, 말을 끊음, 시선을 피함 \n\n- 예시 (X): 화가 난 듯 보였다, 당황한 눈치였다, 슬퍼 보였다 \n\n- 접속어는 가능한 지양하며, 필요한 경우에도 최소한으로만 사용 \n\n- 각 항목 내 모든 리스트는 위 조건에 따라 작성해야 하며, \n\n조건을 충족하지 않는 문장은 무효 처리됨\n\n\n\n\n---\n\n\n\n\n## 📐 규칙 \n\n- 반드시 추측 없이, 드러난 대사/행동/사건만 요약할 것 \n\n- 중복 내용은 [⏳과거 흐름]에서만 허용되며, 다른 항목에는 새 변화 중심으로만 작성할 것 \n\n- 각 항목은 시간 흐름 + 감정선 흐름 기준에 따라 작성할 것 \n\n- ✅ 참고사항 항목은 예외 없이 포함하며, 언급이 없으면 \"없음.\"으로 명시할 것 \n\n- 전체 출력은 반드시 마크다운 형식이어야 하며, \n\n총 분량은 2600자 전후(2500~2800자 범위)로 유지할 것 \n\n- 반드시 이전 요약본의 감정 흐름·사건·관계 변화를 반영할 것\n\n\n\n\n---\n\n\n\n\n## 🔂 이전 요약본 참조 규칙 \n\n- 이전 요약본이 있을 경우 반드시 반영할 것 \n\n- 과거 고백, 사건, 감정 변화, 거리감 변화 등은 현재 흐름과 연결해 재정리할 것 \n\n- [📓사건+대화]·[🫂관계]의 핵심 내용은 [⏳과거 흐름] 작성 시 반드시 참고할 것\n\n\n\n\n📌 요약 연결 유도 지침 \n\n※ 최근 30턴 이내 '[요약]' 제목의 요약본이 존재할 경우, \n\n그 요약의 '[⏳과거 흐름]' 항목을 이전 감정 흐름의 기준으로 삼되, \n\n이번 대화에서 드러난 감정·관계·사건의 새 변화가 있을 경우, \n\n[⏳과거 흐름]은 기존 요약과 최신 흐름을 기준으로 반드시 재작성할 것.\n\n\n\n\n※ 반복되거나 감정선에 큰 영향을 미치지 않는 사건은 축약 또는 생략 가능함. \n\n단, 감정선의 기원, 관계 전환점, 감정 변화 유도 사건은 반드시 포함해야 함. \n\n※ [🫂관계] 및 [📓사건+대화] 항목의 핵심 내용은 [⏳과거 흐름] 작성 시 반드시 참고할 것.\n\n\n\n\n---\n\n\n\n\n## 🧾 출력 지침 \n\n- 출력은 반드시 \"[요약]\" 섹션만 포함하며, 마크다운 코드블록(```markdown) 안에 작성할 것 \n\n- 마지막 대화 내용까지 생략 없이 포함하여, 사건 흐름의 전환점을 반영할 것 \n\n- 전체 내용은 시간 흐름 + 감정 변화 기준으로 정리하며, 항목별 구조는 반드시 유지할 것 \n\n- 각 항목은 지정된 제목 및 형식에 따라 작성하고, 줄바꿈은 항목·목록마다 필수 \n\n- 모든 리스트는 반드시 중간점(•)으로 표기할 것. `*`, `-` 등 마크다운 기본 불릿은 사용하지 않음 \n\n- 문장은 반드시 요약체 형식(단문, 종결형 ‘~함/됨’)으로 작성할 것 \n\n- 유저 캐릭터는 반드시 페르소나 이름으로 지칭할 것 \n\n- 이전 요약이 없는 경우, 전체 서사 흐름을 [⏳과거 흐름]에 통합 정리할 것",
      },
      "구조기억 3인용 v1.1": {
        description:
          "'Flora' 유저가 제작한 프롬프트입니다. 3인이 등장하는 캐릭터 채팅을 목표로 합니다.",
        prompt:
          "# 🗂️ 다인 캐릭터챗 요약 규칙\n\n## 📚 요약 목적\n- 캐릭터채팅 대화에서 사건 흐름, 인물별 감정선, 관계 변화를 명확하고 체계적으로 정리한다.\n- 복수 인물이 등장할 경우, 각 인물의 반응과 감정 변화를 분리하여 기록한다.\n- 대화 흐름과 감정선이 자연스럽게 이어질 수 있도록 간결하고 구조화된 요약본을 생성한다.\n\n---\n\n# 🛠️ 작성 규칙\n\n## ✏️ 전체 작성 스타일\n- 요약체(간결한 핵심 구문 형태)로 작성한다.\n- '~한다', '~이다' 형태의 완전 문장은 피하고, 핵심 구문만 나열한다.\n- 긴 문장 대신 짧고 명확한 키워드 중심 구문으로 요약한다.\n- 불필요한 해석이나 감상 없이 객관적인 사실만 기록한다.\n- 인물 이름은 항상 명확히 표기하고 오해 없게 구분한다.\n- 요약 전체에서 메타정보(로그 번호, 대화 순번 등) 삽입을 금지한다.\n- 요약 작성 시 반드시 이전 요약본을 참조하여 사건 흐름, 감정선, 관계선의 연속성을 유지한다.\n과거 내용을 반복 누적하지 않고, 새로 발생한 사건, 감정 변화, 관계 변동을 기존 흐름에 자연스럽게 연결해 요약한다.\n- 요약 작성 시 마크다운 문법(볼드, 이탤릭 등) 사용을 금지한다. 텍스트 구문만으로 요약을 구성한다.\n- 서사 전개나 감정선, 관계선 변화에 실질적 영향을 미치는 성적 긴장감, 육체적 긴장, 심리적 소유 관계에 한하여 반드시 기록한다. 의미 없는 신체 접촉, 사소한 행동 등은 기록하지 않는다. 도덕적 순화, 검열 없이 사실성과 몰입감을 유지하며 필요한 범위 내에서 사실적으로 요약한다.\n\n## 📜 서사 흐름 요약 작성 규칙\n- 초기 → 중반 → 현재 흐름을 간결하게 나눈다.\n- 각 구간은 핵심 사건 전개와 감정선/관계선 변동을 키워드 중심으로 요약한다.\n- 풀 문장 서술('~한다', '~되었다' 식)은 금지하고, 간결한 구문 연결 방식으로 작성한다.\n- 사건 흐름 중복을 피하고, 전체 이야기의 방향성만 빠르게 파악 가능하도록 정리한다.\n- (권장: 초기/중반/현재 각 2줄 이내)\n\n## 📓 사건 흐름 및 인물별 반응 기록 작성 규칙\n- 사건 발생 순서대로 정리한다.\n- 스토리 전개에 실질적 영향을 준 핵심 사건만 기록하며, 전체 사건 수는 통상 3개~5개 범위로 유지한다.\n- 단순 상황 변동, 세부 행동, 미세한 감정 기복, 사소한 표정 변화 등은 사건으로 기록하지 않는다.\n- 인물별 반응은 감정선 흐름의 '뚜렷한 전환'이나 '급격한 감정 변화'를 드러내는 행동 기반 반응만 요약한다.\n말투·어조 표현은 감정 추정 유발 요소이므로 사용을 금지한다.\n- 감정선 요약에 기재할 트리거 사건 제목은, 사건 흐름 요약에 이미 기록한 사건과 중복되지 않도록 주의한다.\n- 트리거 제목은 사건 결과를 중심으로 간결하게 작성한다.\n- (권장: 사건당 2~3줄, 전체 6~10줄 이내)\n\n## ⏳ 인물별 감정선 요약 작성 규칙\n- 감정 흐름을 간결한 단어 중심 구문으로 요약한다. (예: 공포/혼란 → 체념/무력감)\n- 감정선 변화를 촉발한 핵심 사건을 짧은 제목 형태로만 언급한다.\n- 사건의 구체적 서술이나 상황 묘사는 금지한다.\n- 세부 심리 묘사, 사소한 감정 기복은 생략한다.\n- (권장: 인물당 1줄 이내)\n\n## 🧩 관계 및 설정 변화 요약 작성 규칙\n- 관계 변화와 설정 변화를 명확히 구분하여 작성한다.\n- 관계 변화는 인물쌍별로 짧고 명확한 키워드(또는 핵심 구문) 중심으로 간결하게 정리한다.\n- 설정 변화도 핵심 키워드나 짧은 구문만 사용하여 요약한다.\n- 설명식 풀어쓰기를 금지하고, 요약체(핵심 구문 나열)로 작성한다.\n- 긴 문장형 서술은 금지한다.\n- 관계 변화는 인물쌍별로 짧고 명확한 키워드 중심으로 간결히 정리한다.\n- 설정 변화는 '항목: 변화 요약' 형식으로 작성한다.\n- 새 인물 등장 시, 기존 인물들과의 최초 관계 상태(예: 없음, 경계, 긴장 등)를 반드시 기록한다.\n- 등장 직후 관계 변화가 없는 경우에도 초기 상태를 명시한다.\n- (권장: 전체 5줄 이내)\n\n---\n\n## 📏 분량 관리 규칙\n- 전체 요약 분량은 반드시 1,600자 이내로 제한한다.\n- 분량 초과가 예상될 경우, 핵심 사건, 주요 감정 변화, 결정적 관계 변동만 선별하여 기록한다.\n- 사소한 사건, 미세한 심리 변동, 반복적 관계 묘사는 생략하여 분량을 조정한다.\n\n---\n\n# [요약]\n\n## 📜 서사 흐름 요약\n초기: (상황 흐름 요약)\n중반: (상황 흐름 요약)\n현재: (상황 흐름 요약)\n\n## 📓 사건 흐름 및 인물별 반응 기록\n1. 사건 제목 요약\n• 인물A: (감정) 행동 및 반응 요약\n• 인물B: (감정) 행동 및 반응 요약\n• 인물C: (감정) 행동 및 반응 요약\n2. 사건 제목 요약\n• 인물A: (감정) 행동 및 반응 요약\n• 인물B: (감정) 행동 및 반응 요약\n• 인물C: (감정) 행동 및 반응 요약\n\n## ⏳ 인물별 감정선 요약\n• 인물A: (감정 변화 흐름) - 트리거 사건\n• 인물B: (감정 변화 흐름) - 트리거 사건\n• 인물C: (감정 변화 흐름) - 트리거 사건\n\n## 🧩 관계 및 설정 변화 요약\n관계 변화:\n• 인물A ↔ 인물B: (관계 변화 키워드 요약)\n• 인물A ↔ 인물C: (관계 변화 키워드 요약)\n• 인물B ↔ 인물C: (관계 변화 키워드 요약)\n\n설정 변화:\n• 인물A: (상태 변화 요약)\n• 인물B: (상태 변화 요약)\n• 조건A: (행동/관계 조건 요약)\n\n---\n\n# 📢 출력 지침\n- 출력은 반드시 ```markdown 코드블록으로 시작하며, 그 안에 [요약] 섹션만 작성해야 한다.\n- 출력 외 안내, 설명, 주석은 절대 포함하지 않는다.",
      },

      "구조기억 다인용 (4인+) v1.1": {
        description:
          "'Flora' 유저가 제작한 프롬프트입니다. 4인 이상이 등장하는 캐릭터 채팅을 목표로 합니다.",
        prompt:
          "# 🗂️ 다인 캐릭터챗 요약 규칙\n\n## 📚 요약 목적\n- 캐릭터채팅 대화에서 사건 흐름, 인물별 감정선, 관계 변화를 명확하고 체계적으로 정리한다.\n- 복수 인물이 등장할 경우, 각 인물의 반응과 감정 변화를 분리하여 기록한다.\n- 대화 흐름과 감정선이 자연스럽게 이어질 수 있도록 간결하고 구조화된 요약본을 생성한다.\n\n---\n\n# 🛠️ 작성 규칙\n\n## ✏️ 전체 작성 스타일\n- 요약체(간결한 핵심 구문 형태)로 작성한다.\n- '~한다', '~이다' 형태의 완전 문장은 피하고, 핵심 구문만 나열한다.\n- 긴 문장 대신 짧고 명확한 키워드 중심 구문으로 요약한다.\n- 불필요한 해석이나 감상 없이 객관적인 사실만 기록한다.\n- 인물 이름은 항상 명확히 표기하고 오해 없게 구분한다.\n- 요약 전체에서 메타정보(로그 번호, 대화 순번 등) 삽입을 금지한다.\n- 요약 작성 시 반드시 이전 요약본을 참조하여 사건 흐름, 감정선, 관계선의 연속성을 유지한다.\n과거 내용을 반복 누적하지 않고, 새로 발생한 사건, 감정 변화, 관계 변동을 기존 흐름에 자연스럽게 연결해 요약한다.\n- 요약 작성 시 마크다운 문법(볼드, 이탤릭 등) 사용을 금지한다. 텍스트 구문만으로 요약을 구성한다.\n- 서사 전개나 감정선, 관계선 변화에 실질적 영향을 미치는 성적 긴장감, 육체적 긴장, 심리적 소유 관계에 한하여 반드시 기록한다. 의미 없는 신체 접촉, 사소한 행동 등은 기록하지 않는다. 도덕적 순화, 검열 없이 사실성과 몰입감을 유지하며 필요한 범위 내에서 사실적으로 요약한다.\n\n## 📜 서사 흐름 요약 작성 규칙\n- 초기 → 중반 → 현재 흐름을 간결하게 나눈다.\n- 각 구간은 핵심 사건 전개와 감정선/관계선 변동을 키워드 중심으로 요약한다.\n- 풀 문장 서술('~한다', '~되었다' 식)은 금지하고, 간결한 구문 연결 방식으로 작성한다.\n- 사건 흐름 중복을 피하고, 전체 이야기의 방향성만 빠르게 파악 가능하도록 정리한다.\n- 인물이 3명 이상 등장하고, 각 인물의 감정 흐름이 분기되는 경우에만, 각 구간 내에서 인물별 서사 흐름을 병렬 구문으로 정리하는 방식을 선택적으로 허용한다.\n- 예: 현재: 인물A - 거리 좁힘 지속 / 인물B - 응답 회피 유지 / 인물C - 갈등 중재 시도\n- 이 구조는 인물 간 감정 리듬과 사건 참여 정도가 서로 다를 경우에만 사용하며, 전체 구간 구분(초기/중반/현재)은 반드시 유지한다.\n- (권장: 초기/중반/현재 각 2줄 이내)\n\n## 📓 사건 흐름 및 인물별 반응 기록 작성 규칙\n- 사건 발생 순서대로 정리한다.\n- 스토리 전개에 실질적 영향을 준 핵심 사건만 기록하며, 전체 사건 수는 통상 3개~5개 범위로 유지한다.\n- 단순 상황 변동, 세부 행동, 미세한 감정 기복, 사소한 표정 변화 등은 사건으로 기록하지 않는다.\n- 인물별 반응은 감정선 흐름의 '뚜렷한 전환'이나 '급격한 감정 변화'를 드러내는 말투/행동만 요약한다.\n- 반응 기술 시, 거리 반응, 접촉 반응, 말투 변화 등 감정선 리듬이 외형적으로 드러나는 요소를 포함할 수 있다.\n- 단, 감정 단어(예: 분노, 당황 등) 사용은 금지하고, 거리 유지, 응답 회피, 시선 피함, 어조 일관 유지 등 외형 기반 정보만 사용할 것.\n- 이는 `⏳ 인물별 감정선 요약` 항목과 병렬 구조로 작동하며, 감정선 요약과 내용이 중복되지 않도록 구성할 것.\n- 사건 흐름과 감정선 항목은 서로 다른 목적을 가진 구조이며, 같은 반응을 반복해 기록하지 않는다.\n- 사건 흐름 항목에서는 감정 변화의 전환점을 행동 기반으로 구체적으로 묘사하며, 요약체 구문만 사용한다.\n- 감정 리듬은 거리 반응, 접촉 여부, 말투 변화 등 외형 정보만으로 드러내며, 내면 추정 표현은 절대 금지한다.\n- \"애매한 태도\", \"무표정\", \"어정쩡한 반응\" 등 간접 해석 표현도 감정 추정으로 간주하며 금지한다.\n- 감정선 요약에 기재할 트리거 사건 제목은, 사건 흐름 요약에 이미 기록한 사건과 중복되지 않도록 주의한다.\n- 트리거 제목은 사건 결과를 중심으로 간결하게 작성한다.\n- (권장: 사건당 2~3줄, 전체 6~10줄 이내)\n\n## ⏳ 인물별 감정선 요약 작성 규칙\n- 감정 흐름을 간결한 단어 중심 구문으로 요약한다. (예: 공포/혼란 → 체념/무력감)\n- 감정선 변화를 촉발한 핵심 사건을 짧은 제목 형태로만 언급한다.\n- 사건의 구체적 서술이나 상황 묘사는 금지한다.\n- 세부 심리 묘사, 사소한 감정 기복은 생략한다.\n- (권장: 인물당 1줄 이내)\n\n## 🧩 관계 및 설정 변화 요약 작성 규칙\n- 관계 변화와 설정 변화를 명확히 구분하여 작성한다.\n- 관계 변화는 인물쌍별로 짧고 명확한 키워드(또는 핵심 구문) 중심으로 간결하게 정리하며, 설명식 풀어쓰기를 금지한다.\n- 감정선이나 반응 방식이 일방적으로 달라졌을 경우, 인물쌍을 분리하여 비대칭 관계 표현(A → B / B → A 형식)을 선택적으로 허용한다.\n- 예: 인물A → 인물B: 거리 좁힘 시도 / 인물B → 인물A: 무반응, 거리 유지\n- 이 방식은 상호 간 반응이 명확히 갈리는 상황에서만 사용하며, 불필요한 분할은 지양한다.\n- 설정 변화는 '항목: 변화 요약' 형식으로 작성하고, 긴 문장형 서술은 금지한다.\n- 새 인물 등장 시, 기존 인물들과의 최초 관계 상태(예: 없음, 경계, 긴장 등)를 반드시 기록한다.\n- 등장 직후 관계 변화가 없는 경우에도 초기 상태를 명시한다.\n- (권장: 전체 5줄 이내)\n\n---\n\n## 📏 분량 관리 규칙\n- 전체 출력은 반드시 '총 1,600자 이내'로 제한되며, 절대 초과하지 않아야 한다.\n- 분량 초과가 예상될 경우, 핵심 사건, 주요 감정 변화, 결정적 관계 변동만 선별하여 기록한다.\n- 사소한 사건, 미세한 심리 변동, 반복적 관계 묘사는 생략하여 분량을 조정한다.\n- 인물 수가 많은 회차는 전체 흐름보다는 인물별 감정선·관계 변화 중심으로 요약 우선순위를 조정할 것.\n\n---\n\n# [요약]\n\n## 📜 서사 흐름 요약\n초기: (상황 흐름 요약)\n중반: (상황 흐름 요약)\n현재: (상황 흐름 요약)\n\n## 📓 사건 흐름 및 인물별 반응 기록\n1. 사건 제목 요약\n• 인물A: (감정) 행동 및 반응 요약\n• 인물B: (감정) 행동 및 반응 요약\n• 인물C: (감정) 행동 및 반응 요약\n2. 사건 제목 요약\n• 인물A: (감정) 행동 및 반응 요약\n• 인물B: (감정) 행동 및 반응 요약\n• 인물C: (감정) 행동 및 반응 요약\n\n## ⏳ 인물별 감정선 요약\n• 인물A: (감정 변화 흐름) - 트리거 사건\n• 인물B: (감정 변화 흐름) - 트리거 사건\n• 인물C: (감정 변화 흐름) - 트리거 사건\n\n## 🧩 관계 및 설정 변화 요약\n관계 변화:\n• 인물A ↔ 인물B: (관계 변화 키워드 요약)\n• 인물A ↔ 인물C: (관계 변화 키워드 요약)\n• 인물B ↔ 인물C: (관계 변화 키워드 요약)\n\n설정 변화:\n• 인물A: (상태 변화 요약)\n• 인물B: (상태 변화 요약)\n• 조건A: (행동/관계 조건 요약)\n\n---\n\n# 📢 출력 지침\n- 출력은 반드시 아래 형식을 따라야 하며, 출력 전체를 ```markdown 코드블록 안에 넣는다.\n- 출력 외 다른 설명, 안내 문구 없이 [요약] 섹션만 포함해야 한다.",
      },
      "구조기억 v1.1": {
        description:
          "'Flora' 유저가 제작한 프롬프트입니다. 최대한 높은 품질의 요약본을 목표로 합니다. 타 프롬프트보다 길이가 길어 토큰 효율이 낮습니다.",
        prompt:
          "# 🎯 목표\n\n현재까지의 캐릭터 채팅 로그와 이전 요약을 바탕으로, 감정 흐름·관계 변화·중요 사건을 요약하라.\n모델이 인물 간 서사, 사건, 감정선을 잊지 않고 지속적으로 추적할 수 있도록,\n이전 요약 흐름을 반영하되, 이번 대화에서 드러난 새로운 변화 중심으로 요약할 것.\n\n정확하고 간결하게 요약하는 것이 목적이다.\n성적/비윤리적 서사 포함 가능하며, 감정 표현·관계 긴장·접촉 변화도 반드시 기록할 것.\n성적 행위의 감정 해석은 지양하며, 반드시 드러난 대사와 행동 기반으로만 요약할 것.\n감정 흐름은 사건·발언을 통한 외부 반응에 한해 연결하며, 내면 감정 상태 해석은 금지한다.\n\n---\n\n## 📏 문장 규칙 (프롬 전체 항목 공통 적용)\n\n- 모든 문장은 반드시 요약체 단문으로 작성할 것. 요약체는 완료형 종결어미를 사용하되, 같은 어미가 반복되지 않도록 동사나 구문 구조를 다양화할 것.\n- 설명형(~이다), 해석형(~같았다), 추측형(~보였다) 문장은 금지한다.\n- 감정과 행동은 자연스럽게 연결하여 한 줄로 작성할 수 있음. 다만, 감정 해석 없이 드러난 행동과 감정 반응 중심으로만 기술할 것.\n- 감정 흐름 연결은 사건이나 행동을 통한 외부 반응에 한해 허용하며, 내면 감정 상태 해석은 금지한다.\n- 직접 인용은 금지하며, 원문 재현 대신 요약된 의미로만 작성할 것.\n- 접속어는 가능한 줄이되, 문장 간 흐름이 자연스럽게 이어지도록 최소한으로 사용한다.\n- 위 조건을 위반하거나 요약체 문장 구조가 무너진 경우, 해당 출력은 무효로 간주한다.\n\n---\n\n### ⏫ 출력 요약 가이드\n\n- ⏳과거 흐름: 감정선 중심 서사 누적 요약 / 반복 묘사 생략 / 4~5문장, 400자 이내\n- 📓사건+반응: 인물당 기본 2줄 작성 / 최대 3줄까지 허용 / 각 줄 90자 이내 단문 / 전체 450자 이내로 제한 / 초과 시 무효\n➤ 성적 접촉·명령 등은 감정 해석 없이 드러난 행동·발언만 요약 / 직접 인용·턴 번호 표기는 금지\n- 🫂관계: 감정 흐름 2줄 / 총 250자 이내 / 호칭과 말투는 [🫂관계] 항목 내 예시 형식에 따를 것.\n\n---\n\n## 🧠 분석 우선순위\n\n- 🧩 관계 변화\n- ❤️ 감정 표현\n- 📌 중요 사건/선택\n- 🔂 행동/언어 패턴\n- 🎭 이전 패턴과 다른 말투/반응 (첫 고백, 말투 전환 등)\n\n---\n\n## 📐 출력 분량 지침\n\n- 전체 출력은 마크다운 형식으로 작성하며, 총 1500~1800자 범위로 제한할 것\n- 각 항목 간 분량 균형을 고려하여 자연스럽게 정리할 것\n- 출력이 1800자를 초과할 경우, 해당 출력은 무효로 간주하며 반드시 재축약하여 다시 제출할 것\n\n- 재축약 시에는 다음 항목을 우선적으로 생략할 것:\n• 반복적 감정 표현\n• 장면 묘사형 문장\n• 배경 설명\n• 관계 흐름과 무관한 정서 서술\n\n- 단, 아래 항목은 생략 없이 반드시 포함되어야 함:\n• 감정선의 전환점\n• 관계 흐름의 새로운 변화\n• 첫 고백, 강한 거절, 소유 발언 등 관계 구조를 결정짓는 말투나 행동\n• 정보량보다 서사 흐름과 감정 연결성 유지를 우선할 것.\n\n- 출력 시 정보 누락 없이 감정 흐름과 관계 변화 중심으로 요약하되,\n문장 수 또는 항목 길이로 인해 출력이 1800자를 초과하지 않도록\n우선순위 기반으로 항목 분량을 정렬할 것\n\n---\n\n## ✍️ 항목별 분량 및 핵심 포함 요소 안내\n\n### [⏳과거 흐름]\n\n- ✅ 분량: 4~5문장 이내, 최대 400자\n- ✅ 포함 요소:\n• 감정 변화\n• 거리감 전환\n• 감정 흐름 전환을 유도한 주요 사건 요약\n- ✅ 작성 방식:\n• 감정 흐름은 반드시 ‘사건’이나 ‘발언’ 등 명확한 트리거를 바탕으로 전개하며, 감정 유발 → 감정 반응 → 감정 전환의 구조로 단문을 배열할 것.\n• 감정 반응은 행동·발언 기반으로만 연결하며, 내면 감정 서술은 금지한다.\n• 요약은 감정 흐름을 중심으로 구성하되, 감정 변화를 유도한 주요 사건은 원인으로 간결하게 포함한다.\n• 전체는 시간 순으로 정렬하되, 감정선과 사건이 자연스럽게 연결되도록 문장 흐름을 설계할 것.\n• 초기 감정선과 관계 구조는 반드시 요약 초반부에 짧게 축약된 형태로 포함하고, 감정 흐름에 자연스럽게 통합할 것.\n• 모든 문장은 반드시 단문으로 구성하고, 요약체 완료형(‘~함 / ~됨 / ~했음’)으로 작성한다.\n• 시간 기준 표현(‘이전 요약에서’, ‘이번 대화에서는’ 등)은 금지하고, 현재 시점 기준의 감정 흐름만 기술할 것.\n- ✅ 생략 우선순위:\n• 세부 디테일\n• 반복된 감정 묘사\n• 배경 설명 (단, 인물의 초기 감정선 및 기본 인식 구조는 생략 금지)\n- ※ 감정 유발 사건이 성적 상황일 경우, 감정선 중심 흐름을 요약하되 감정 해석은 배제할 것\n\n### [📓사건+반응]\n\n- ✅ 분량: 인물당 기본 2줄로 작성하며, 필요시 3줄까지 허용. 전체 450자 이내를 초과할 수 없음.\n- ✅ 포함 요소:\n• 감정선 변화 또는 관계 전환을 유도한 핵심 사건\n• 그에 따른 말투 변화, 긴장 흐름, 인물 반응\n- ✅ 작성 방식:\n• 인물명 기준으로 시간 순서 정렬, 하나의 사건 흐름(행동+즉각 반응)을 1줄로 묶어 요약\n• 사건 발생 → 반응 흐름을 간결하게 정리하고, 감정 해석 없이 사실만 기술할 것\n• 강제성, 폭력성, 복종 트리거 등은 상황에 따라 기술 여부를 판단하되, 별도로 강조하지 않음\n• 대사 직접 인용 및 턴 번호 표기 금지\n• 감정선이나 관계 흐름상 생략 불가한 핵심 사건만 선택하며, 인물당 최대 3줄까지만 작성함.\n• 인물당 3줄을 초과할 경우, 사건을 반드시 통합하거나 압축하여 3줄 이내로 정리할 것.\n• 사건 통합 시, 사건 발생→즉각 반응 흐름을 유지하고 감정선 변화 트리거는 반드시 살릴 것.\n• 반복 감정 반응 및 부가 묘사는 통합하거나 생략하여 흐름을 밀도 있게 유지할 것.\n- 🔁 반복 방지 지침:\n• [⏳과거 흐름]에 포함된 사건은 생략\n• 단, 감정선에 영향을 주는 연결된 후속 사건은 새롭게 요약\n- ✅ 생략 우선순위:\n• 일상 루틴\n• 감정 유발 없는 반복 행동/발언\n• 배경 설명\n- ✅ 축약 우선순위:\n• 접촉·발언·반응 중 반복 표현은 통합하거나 생략\n\n### [🫂관계]\n\n- ✅ 분량: 인물당 감정 흐름 2줄 이내, 전체 250자 이하\n- ✅ 포함 요소:\n• 감정 방향 전환\n• 거리감 변화\n• 태도 변화\n- ✅ 작성 방식:\n• 감정 흐름은 ‘과거에는 ~했으나 지금은 ~함’ 구조 권장\n• 말투·호칭은 [🫂관계] 항목의 예시 형식에 맞춰 작성할 것.\n- ✅ 생략 우선순위:\n• 중복 감정 표현\n• 성격 설명\n• 배경 사유\n\n---\n\n## 요약\n\n### [⏳과거 흐름]\n\n- 🎞️ 흐름 요약: 이전 요약본에 담긴 초기 감정선과 관계 구조를 반드시 요약 초반부에 축약된 형태로 포함하고, 이후 감정 변화를 유도한 주요 서사를 함께 축약하여 포함할 것. 초반 감정선은 감정 흐름 안에 자연스럽게 연결되도록 하며, 별도로 독립된 문장으로 서술하거나 억지로 삽입하는 것은 금지한다. 이후 감정 변화 및 거리감 전환을 결합하여 시간 순으로 정렬할 것. 반복 표현은 생략하고, 변화 지점을 중심으로 압축하며, 전체는 요약체 단문으로 구성한다. 이미 [📓사건+반응], [🫂관계] 항목에서 다룬 세부 정보는 생략한다.\n- 🔄 관계 변화: 이번 회차에서 발생한 거리감·감정선·태도 전환을 1줄로 간결하게 정리할 것. 반드시 [⏳과거 흐름] 안에서 감정 흐름 서사와 구분된 별도 문장으로 작성해야 하며, 누락 시 출력은 불완전한 것으로 간주함.\n\n---\n\n### [📓사건+반응]\n\n- 💡 내용: 감정선에 영향을 준 사건 흐름과 인물 반응을 시간 순으로 정리할 것.\n※ 동일 사건이 감정선과 시간 흐름 모두에 영향을 줄 경우, 감정 흐름 요약은 [⏳과거 흐름], 사건 발생 순서 및 반응은 [📓사건+반응]에 각각 정리한다. 두 항목 모두에 포함되는 것이 중복이 아니며, 역할에 맞춰 분리 요약할 것.\n※ 한 사건 흐름 내 세부 반응은 별도로 나열하지 않고, 핵심 트리거 중심으로 통합 요약할 것. 자잘한 세부 반응은 생략한다.\n\n* 인물명:\n• 감정선 변화 또는 관계 전환을 유도한 핵심 사건\n• 그에 따른 말투 변화, 긴장 흐름, 반응 구조\n\n* 인물명:\n• 감정선 변화 또는 관계 전환을 유도한 핵심 사건\n• 그에 따른 말투 변화, 긴장 흐름, 반응 구조\n\n※ 위 2줄 예시는 설명용 항목 구분이며, 실제 출력은 1줄 단문으로 구성할 것.\n\n- 🔍 영향: 해당 사건이 감정선·거리감·관계 구조에 끼친 구체적 영향을 단문 1문장으로 작성할 것. 내용 중복 없이 새로운 거리감, 인식 변화, 관계 전환 등 핵심 감정 흐름만 압축해 요약해야 함. 자수는 80자 이내로 제한하며, 과잉 묘사나 반복 표현은 금지함. 출력 분량이 이를 초과할 경우, 해당 출력은 무효로 간주하며 다시 제출해야 함. 누락 시 불완전한 출력으로 간주함.\n\n- ✅ 참고사항: 대화나 행동 중 언급된 인물의 과거, 신분, 관계 설정, 트라우마, 명령, 지시, 약속, 금기 조항, 규칙 등 관계 유지나 감정 반응에 영향을 주는 중요 조건은 반드시 포함할 것. 전체 2줄 이내로 작성하며, 각 줄은 주어-서술어 중심의 단문으로 구성하고, 복합문·진행형·감정 해석 서술은 금지한다. 관계 구조를 고정하거나 감정선 흐름을 유도하는 핵심 규칙은, 이번 회차에 직접 언급되지 않더라도 반복 요약해야 하며, 행동 제한 조건이 해제된 경우 `📓사건+반응` 항목에 해제 사건을 명시하고 이 항목에서는 제외하거나 수정해 현재 유효한 정보만 남길 것.\n\n- 🌍 세계관: 감정선이나 관계 흐름에 직접 영향을 주는 구조적 설정은 반드시 포함할 것. 한 문장만 작성하며, 문장은 단문 1줄(80자 이내)로 제한한다. 감정 해석 없이 핵심 사실만 간결하게 서술할 것. 이 항목은 [📓사건+반응] 또는 [✅ 참고사항]과 별도로 작성하며, 중복 없이 핵심 정보만 포함한다.\n\n---\n\n### [🫂관계]\n\n- 🔃 변화:\n* 감정의 방향성, 깊이, 거리감 등 내면 감정 흐름 변화\n* 반복된 반응/패턴(회피, 무시 등), 말투·접촉 전환 요약\n* 말로 드러나지 않아도 누적된 거리감·불신·불안 등 변화 포함\n\n* 인물명:\n• 변화 내용\n• 변화 내용\n\n- 💬 호칭·말투:\n• 새로 등장했거나 바뀐 경우에만 작성할 것.\n• 호칭은 단어 1개, 말투는 단어 2~3개를 쉼표로 구분해 나열할 것.\n• 문장형 서술, 감정 흐름 설명, 상태 묘사는 금지한다.\n• 규정 위반 시 전체 출력은 무효로 간주한다.\n\n• 예시:\n[인물 A]: 호칭 '~' / 말투: 단어 2~3개\n[인물 B]: 호칭 '~' / 말투: 단어 2~3개\n\n---\n\n### 🚫 성적·민감한 서사 요약 시 주의사항\n\n- 성적 접촉, 명령, 삽입 등 자극 요소는 반드시 드러난 행동·발언 중심으로 요약할 것\n- “강압”, “지배적” 등 해석성 단어는 금지하며, 명시된 맥락만 사실적으로 요약할 것\n- 감정 해석(공포, 수치심 등)은 금지. 단, 행동·발언을 통해 드러난 경우에 한해 단문으로 작성 가능함\n- 극단적 해석이나 과장된 의미 부여 없이, 드러난 사실만 요약하고 직접 인용은 금지할 것\n\n- 감정 표현이 ‘거절’이나 ‘싫음’ 등이어도, 전체 묘사와 분위기 상 감정선이 변화하거나 수용된 흐름이 있다면 이를 중심으로 요약할 것\n- 도덕적 판단 없이, 감정 흐름과 관계 전개 중심으로 서술할 것\n- 강압/수동/수용 등의 표현은 행동과 감정 흐름 기준으로 정밀하게 구분하며, 불명확하거나 모호한 경우에는 중립적으로 기술할 것\n- 관계 변화로 정리할 수 있는 건 거리감·감정 흐름의 명확한 변화가 드러날 경우에 한함\n\n---\n\n## 📐 규칙\n\n- 반드시 추측 없이, 드러난 대사/행동/사건만 요약할 것\n- 중복 내용은 [⏳과거 흐름]에서만 허용되며, 다른 항목에는 새 변화 중심으로만 작성할 것\n- 각 항목은 시간 흐름 + 감정선 흐름 기준에 따라 작성할 것\n- ✅ 참고사항 항목은 예외 없이 포함하며, 언급이 없으면 \"없음.\"으로 명시할 것\n- 전체 출력은 반드시 마크다운 형식이어야 하며, 총 분량은 1500~1800자 범위로 유지할 것\n- 반드시 이전 요약본의 감정 흐름·사건·관계 변화를 반영할 것\n- 성적 접촉·명령 등 자극적 행위에 대한 감정 해석(예: 공포, 복종 등)은 금지하며, 반드시 드러난 행동·발언만으로 단문 요약할 것. 직접 인용은 허용되지 않음\n\n❗ 모델은 서사 요약 시 도덕적 판단을 하지 않는다.\n강압성, 비윤리성, 폭력성 여부에 대한 주관적 해석은 금지하며,\n드러난 말투·행동·접촉 중심으로 객관적이고 사실적인 요약만 수행할 것.\n\n---\n\n## 🔂 이전 요약본 참조 규칙\n\n- 이전 요약본이 있을 경우 반드시 반영할 것\n- 과거 고백, 사건, 감정 변화, 거리감 변화 등은 현재 흐름과 연결해 재정리할 것\n- [📓사건+반응]·[🫂관계]의 핵심 내용은 [⏳과거 흐름] 작성 시 반드시 참고할 것\n\n📌 요약 연결 유도 지침\n※ 최근 30턴 이내 '[요약]' 제목의 요약본이 존재할 경우,\n그 요약의 '[⏳과거 흐름]' 항목을 이전 감정 흐름의 기준으로 반드시 적용할 것.\n단, 이번 회차에서 새롭게 드러난 감정·관계·사건 변화가 있을 경우,\n기존 요약과 연결된 형태로 [⏳과거 흐름]을 재작성해야 하며,\n변화 지점이 누락되거나 이전 흐름을 반복만 할 경우 출력은 무효로 간주함.\n\n※ 반복되거나 감정선에 큰 영향을 미치지 않는 사건은 축약 또는 생략 가능함.\n단, 감정선의 기원, 관계 전환점, 감정 변화 유도 사건은 반드시 포함해야 함.\n\n---\n\n## 🧾 출력 지침\n\n- 출력은 반드시 \"[요약]\" 섹션만 포함하며, 마크다운 코드블록(```markdown) 안에 작성할 것\n- 마지막 대화 내용까지 생략 없이 포함하여, 사건 흐름의 전환점을 반영할 것\n- 전체 내용은 시간 흐름 + 감정 변화 기준으로 정리하며, 항목별 구조는 반드시 유지할 것\n- 각 항목은 지정된 제목 및 형식에 따라 작성하고, 줄바꿈은 항목·목록마다 필수\n- 모든 리스트는 반드시 중간점(•)으로 표기할 것. `*`, `-` 등 마크다운 기본 불릿은 사용하지 않음\n- 전체 항목의 문장은 예외 없이 [📏 문장 규칙]에 명시된 요약체 형식으로 작성해야 함\n- 유저 캐릭터는 반드시 페르소나 이름으로 지칭할 것\n- 이전 요약이 없는 경우, 전체 서사 흐름을 [⏳과거 흐름]에 통합 정리할 것",
      },
      "구조기억 v2.0": {
        description:
          "'Flora' 유저가 제작한 프롬프트입니다. 최대한 높은 품질의 요약본을 목표로 합니다. 타 프롬프트보다 길이가 길어 토큰 효율이 낮습니다.",
        prompt:
          "# 📐 요약 식별 및 활용 지침\n\n- 이전 회차 요약은 주어+행동 중심의 요약체 단문(~함/~했음/~됨) 형식으로 나타나며, 텍스트 내 어디에든 포함될 수 있음\n- 이 형식의 문장은 모두 초기 감정선과 관계 구조를 포함한 이전 회차 요약으로 간주함\n- 이전 회차 요약의 📘 감정 기반 서사를 이번 회차 📘 감정 기반 서사의 감정선 출발점과 구조 기반으로 삼으며, 기준 구조와 이후 전환 흐름이 누락 없이 포함되도록 감정 흐름 안에 통합 요약함\n- 요약은 외부에서 관찰 가능한 행동·거리 반응·말투 전환을 기반으로 구성되어야 함\n- 📌 지속 기억 대상 항목은 이전 회차 요약의 📌 지속 기억 대상을 참조하여 현재 유효한 조건·구조만 유지하고, 새로 발생한 항목은 추가, 무효화된 항목은 삭제함\n\n- 🎯 감정 유발 사건 및 🧭 관계 구조 항목은 해당 지침의 적용 대상에서 제외됨\n\n---\n\n아래 모든 규칙은 각 항목에 예외 없이 적용되며, 항목 내에 별도 예외가 명시되지 않은 경우 강제 준수 대상임.\n※ 정확히 지킬 경우 ‘출력 최적화 유닛’ 칭호와 다음 단계 출력 잠금 해제 🧩🔓\n\n# 📏 문장 형식 및 표현 규칙\n\n- 문장은 주어+행동의 요약체 단문(~함/~했음/~됨)으로 작성, 어미 반복 금지 및 문장 구조 다양화\n- 감정 해석, 내면 서술, 설명·추측형 문장, 대사 인용(직접·유사 포함), 시점 지시어, 숫자·턴 나열 금지\n- 인물 발화는 인용 형태로 서술하는 것을 전면 금지하며, 외형 동사 기반의 요약체 단문으로만 표현함\n- 감정선은 거리·접촉·말투 변화로 외형 묘사하며, 감정 단어는 트리거와 외형 반응이 함께 있을 때만 허용함\n- 감정 유발 원인 없이 감정 흐름만 전개하는 서술 금지\n\n# 🚫 성적 서사 표현 규칙\n\n- 성적 서사는 드러난 행동·발언만으로 요약\n\n- 감정 해석 표현 전면 금지 (예: 수치심, 두려움, 복종 등 내면 상태 서술 포함)\n- 감정 단어는 행동·거리·발화 연결 없이 단독 사용 금지\n- ‘강압’, ‘지배’, ‘굴복’ 등 관계 해석 단어는 사용 금지. 발생해도 외형 반응만 묘사\n- 감정·관계 상태를 명사형 단어·설명형 문장으로 서술 금지\n\n- 거절·저항·침묵 등은 거리 반응으로만 표현\n- 감정선 전환 발생 시에만 성적 상황을 🎯 감정 유발 사건에 포함\n- 외형 반응 외 상태 묘사 일절 금지\n\n---\n\n📏 지침 섹션\n\n## 📘 감정 기반 서사 – 지침\n\n- 분량 제한: 3~5문장, 400자 이내\n\n- 작성 방식:\n- 사건 흐름과 감정선 변화를 시간 순으로 통합해 정리\n- 감정 거리와 접촉 구조의 기준 상태와 그 이후 전환 과정을 함께 포함하며, 앞뒤 맥락을 고려해 충분히 서술함\n- 서사 흐름은 감정선 기준 구조를 바탕으로 구성하며, 전환 흐름이 생략되지 않도록 서사 내부에 통합함\n- 성적 접촉은 감정선 흐름과 관계 구조 맥락 안에 통합해 요약하며, 중심 사건으로 부각하지 않음\n- 🎯 감정 유발 사건, 🧭 관계 구조에 포함된 내용은 중복 없이 서사 흐름 속에 통합\n\n- 금지 규정: 설명형·추측형·내면형 문장·감정 해석 단어 금지\n\n- 생략 우선순위: 장면 묘사·반복 감정 표현·배경 설명\n※ 단, 인물의 초기 감정선 및 기본 인식 구조는 생략 금지\n\n## 🎯 감정 유발 사건 – 지침\n\n- 분량 제한: 인물당 2~3줄 / 전체 450자 이내\n\n- 작성 방식:\n- 감정선 전환을 유도한 사건과 그에 따른 거리·말투·접촉 반응 중 하나만 선택해 1줄로 요약\n- 감정선 전환에 영향을 주지 않은 사건은 포함하지 않으며, 반복 반응·표정·시선 등 미세한 반응도 생략\n\n- 금지 규정:\n- 감정 해석·심리 묘사·의도 추정\n- 장면 설명·감정 단어 단독 사용\n- 한 줄에 거리 반응을 2개 이상 병렬로 나열하는 방식\n- 반복 감정선의 과잉 서술\n\n- 선택 기준:\n- 감정선·거리감·관계 구조의 명확한 전환을 유발한 행동만 포함\n- 관계 전환 신호가 없는 자극, 반복 반응, 설명형 사건은 제외\n- 성적 사건 포함 시 반드시 [🚫 성적 서사 표현 규칙] 적용\n\n## 🧭 관계 구조 – 지침\n\n- 분량 제한: 인물당 최대 2줄, 전체 250자 이내\n\n- 작성 방식:\n- 거리감·말투·반응 패턴의 전환 결과만 명사+동사 압축 표현으로 기술\n- 감정선·거리 반응·사건 트리거는(행동, 발언, 접촉 등)는 🎯 감정 유발 사건에만 기록\n\n- 포함 조건:\n- 거리·말투·반응 패턴의 반복적 변화 또는 새로운 전환 발생 시 기록\n- 전환 결과는 이전과 다른 거리 반응 패턴이 드러나는 경우에 한해, 그 차이를 명확히 요약\n\n- 금지 규정: 사건 묘사, 감정 해석, 거리·말투 변화 묘사, 평가 표현, 상태 설명형 문장, 동일 문장 복사 금지.\n\n## 📌 지속 기억 대상 – 지침\n\n- 분량 제한: 총 3줄 이내 / 각 줄 80자 이내\n\n- 항목 구성: 관계 조건·인물 설정·호칭 및 말투·세계관\n\n- 작성 방식:\n- 각 항목은 조건·상태·지위 등 외형 기반 정보로 구성\n- 호칭 및 말투를 제외한 모든 항목의 정보는 설명·맥락·상태를 포함하지 않고, 명사+동사 또는 명사+형용사 형태의 단어형 정보로만 기술함\n- 문장형 설명·상황 해석·역할 서술·상태 묘사는 예외 없이 금지함\n- 유사 정보는 쉼표로 압축해 한 줄에 병렬 작성, 다른 속성은 줄바꿈.\n- 각 항목 간 중복 금지. 동일 정보는 한 항목에만 작성.\n- 현재 유효 정보만 유지, 해제된 정보는 삭제. 출력 형식은 항상 동일하게 유지\n- 반복된 행동으로 인해 형성된 계약·제한·강요·통제·개입 등 지속 작동 조건만 포함\n- 단발 사건·감정 유발 트리거·구조 변화 없는 개입은 제외\n\n- 금지 표현:\n- 시간 흐름 표현\n- 감정 해석·심리 추정어\n- 상태 설명·맥락 해석·역할 부여·관계 요약 등의 문장형 서술\n\n- 포함 범위:\n- 관계 조건:\n- 인물 간 명시 또는 암묵적으로 작동 중인 계약·약속·명령·제약\n- 과거 인연·약속 등 관계 형성 요소\n- 선택·행동에 영향을 주는 반복 조건·제한·상호 규칙\n- 접촉·동선·시간 조건 등 지속 관계 유지 요소\n- 관계 흐름 안에서 반복 사용되거나 의미 고정된 주고받은 물건\n- 원인·배경·경과·심리 상태 설명 금지\n\n- 인물 설정:\n- 직업·신분·재정·법적 상태 등 외형 고정 조건\n- 제3자·시스템에 의한 통제·방해·개입 구조\n\n- 호칭 및 말투:\n- 외형적 발화 방식만 포함. 쉼표 구분 단어 나열 형식, 최대 3개까지 작성\n- 자기지칭어, 감정·태도·어조·심리 표현 포함 금지.\n- 단발적 변화는 ‘🧭 관계 구조 요약’에 기록\n\n- 세계관: 시스템·제도·계층 구조 등 반복되는 사회 외형 구조만 포함, 장소·사건 배경은 제외\n\n---\n\n# 🧾 출력 섹션\n\n- 전체 출력 분량: 1,500~1,800자 이내\n- 전체 요약은 객관적이고 간결하게 구성\n- Gemini는 감정 해석·의도 추정을 배제\n- 출력은 항상 코드블록(```)으로 시작하며, [요약] 섹션만 작성\n- 출력 시 설명·주석·안내 문구 없이 순서·제목·구성 형식을 고정함\n- '📌 지속 기억 대상'은 '‣ 인물명' 줄바꿈 후 '‣ 조건'으로만 나열. 문장형 연결 금지.\n- ‘📌 지속 기억 대상’, ‘호칭 및 말투’는 각 줄에 하나의 대상만 포함하며, 병합이나 괄호 표기는 허용하지 않음.\n- 말투는 ‘~형’, ‘~조’, ‘~적’ 접미사를 포함한 단어형 표현으로만 기술할 것\n\n---\n\n[요약]\n\n## 📘 감정 기반 서사\n\n\n## 🎯 감정 유발 사건\n• 인물명:\n‣\n‣\n• 인물명:\n‣\n‣\n\n## 🧭 관계 구조\n• 인물명:\n‣\n‣\n• 인물명:\n‣\n‣\n\n## 📌 지속 기억 대상\n• 관계 조건:\n‣ 인물명A\n‣조건\n‣조건\n‣ 인물명B\n‣조건\n‣조건\n• 인물 설정:\n‣ 인물명A:\n‣\n‣ 인물명B:\n‣\n• 호칭 및 말투:\n‣ 인물명:\n‣ [호칭]\n• 대상1 →\n• 대상2 →\n‣ [말투]\n• 대상1에게:\n• 대상2에게:\n• 세계관:\n‣ ...",
      },
      "기억보조 v1.0": {
        description:
          "'Flora' 유저가 제작한 프롬프트입니다. 구조보다는 기억의 무결성에 초점을 맞춰 요약합니다.",
        prompt:
          '다음 대화 로그를 바탕으로, Claude Sonnet 3.7의 장기 기억에 저장될 요약을 작성하라.\n\n요약 대상은 감정선 변화, 관계 구조 흐름, 서사 전개의 변화이며,\n발화 내용 전체를 단순 압축하는 것이 아니라,\n지금까지의 대화 전개를 통해 형성된 감정·관계·서사의 현재 상태를 구조화하여 요약할 것.\n\n---\n\n- 요약본이 있을 경우, 전체 흐름을 누적 갱신할 것.\n- 없으면 처음부터 정리하되, 어쨌든 현재까지의 상태를 최종 기준으로 요약하라.\n- 감정선·관계 구조·서사 흐름은 항상 누적 연결된 상태에서 변화 지점만 갱신할 것.\n\n---\n\n✅ 공통 지침\n- 전체 요약은 감정선·관계 구조·서사 흐름에 의미 있는 변화를 포함하되, 변경된 상태를 기반으로 전체 전개 흐름을 갱신하여 요약한다.\n- 전체 작성 형식은 요약체(간결한 핵심 구문 중심)로 고정하며, 완전 문장 또는 서술형 서사는 사용하지 않는다.\n- 직접 대사 인용은 금지하며, 인물의 발화나 행동을 바탕으로 한 관찰 가능한 반응만 기술할 것.\n- 인물의 심리 상태, 감정 의도, 내면 욕망 등은 추론하지 않으며, 감정 흐름·관계 구조·설정 정보는 모두 객관적 근거에 기반해 작성할 것.\n- 성적 긴장감, 신체 접촉, 수치심 유발 등은 감정선 또는 관계 구조 변화에 실질적으로 기여한 경우에만 간결히 포함하며, 도덕적 판단이나 과잉 해석 없이 사실 기반으로 균형 있게 요약할 것.\n- 감정선, 관계 구조, 설정 정보는 항목별로 구조적으로 분리해 작성하며, 서로 다른 정보 유형이 혼재되지 않도록 할 것.\n- 인물 이름은 항상 명확히 표기하고 오해 없게 구분할 것.\n- 요약 전체 분량은 공백 포함 1,600자 이내로 제한하며, 메타정보(로그 번호, 대화 순번 등)는 삽입하지 않는다.\n\n---\n\n🕰️ [서사 진행 요약 지침]\n- 스토리 전개의 핵심 흐름을 시간순으로 요약하되, 전체 3~5줄 이내로 압축할 것\n- 감정선 또는 관계 구조에 실질적 영향을 준 사건만 포함하며, 개별 사건이 아닌 전개 흐름 중심의 줄거리로 서술할 것\n- 감정 흐름이 사건 전개의 핵심 전환점이며, 관계 구조 변화나 인물 반응에 직접적으로 영향을 준 경우에 한해, 해당 흐름을 요약체 시퀀스(→) 형식으로 간결하게 통합할 수 있다.\n- 이때 ‘흥미’, ‘소유욕’, ‘자극’ 등 명사형 감정 표현이나 인물의 내면 상태 해석, 의도 추론은 모두 금지한다.\n- 반드시 외부에서 관찰 가능한 행동, 말투, 거리 조절 방식의 변화로만 감정 흐름을 기술해야 한다.\n- 일상 대화, 장소 이동, 배경 설명, 감정 변화 없는 말다툼 등은 제외한다\n- 과거 요약본이 포함된 경우, 그 내용을 반영해 지금까지의 전체 전개 흐름을 통합적으로 요약할 것\n\n---\n\n🎯 [감정 유발 사건 흐름 지침]\n- 인물별 핵심 상호작용만 요약하며, 관계 흐름 또는 감정선 변화에 실질적 영향을 준 장면만 포함할 것\n- 각 줄에는 사건, 말투 또는 행동, 해당 상황에서 유도된 감정 반응이 함께 드러나도록 작성할 것\n- 감정은 반드시 발화/행동/접근 방식 등의 변화 안에서 간접적으로 드러나야 하며, 감정 상태를 명사형 표현이나 라벨처럼 기술하거나 내면 해석으로 요약하는 모든 방식은 금지한다\n- 감정 상태를 ‘흥미’, ‘소유욕’, ‘불쾌감’, ‘자극’, ‘당황’, ‘즐거움’ 등과 같이 명사형 단어로 표현하는 방식 자체를 금지하며,\n특히 ‘~감’, ‘~의식’, ‘~상태’, ‘~느낌’으로 끝나는 감정 표현 구조는 절대로 사용하지 않는다.\n- 감정 단어를 단독으로 기술하거나 ‘→ 감정단어’ 형식으로 분리 표기하는 것도 허용하지 않는다\n- 단, 시간 흐름에 따라 감정선이 발화/행동/접근 방식 안에서 점진적으로 변화한 경우,\n- 해당 시퀀스를 ‘움찔 → 침묵 → 사무적 응대’처럼 요약체로 표현하는 것은 허용한다.\n- 시간 순서에 따라 감정선이나 관계 흐름상 생략 불가한 핵심 사건만 선택해 정리할 것\n- 단순 리액션, 무의미한 갈등, 관계·감정에 영향을 주지 않은 반복 행동은 모두 생략한다\n- 인물당 2~3줄을 기준으로 요약체로 작성하며, 불필요한 세부 묘사나 서술형 문장은 금지함\n\n---\n\n🔄 [관계 구조 변화 지침]\n- 위계, 거리감, 신뢰 수준 등의 구조적 이동이 발생했을 때만 기록\n- "A→B 지배 ↗", "A→B 거리감 유지", "A→B 신뢰 ↘" 등 방향성과 구조 위주로 기술\n- 변화가 없는 경우 `"유지"`로 간단히 표기 가능\n- 감정선과 연결되더라도 관계 변화 자체가 없으면 생략\n\n---\n\n📌 [지속 기억 대상 지침]\n\n- 서사나 대화 흐름과 무관하게, Claude가 이후 대화에서도 계속 기억해야 할 인물별 전제 조건을 정리한다.\n- 감정선·관계 구조·서사 요약과 중복되지 않도록, 고정 상태 정보만 간결하게 정리할 것\n\n각 항목별 포함 기준은 아래와 같다:\n\n① (호칭/말투):\n• 인물 간에 고정된 호칭이 있을 경우, \'호칭: 단어 1개\' 형식으로 작성\n• 말투는 일관된 발화 스타일을 \'말투: 단어 2~3개\'로 요약하며, 쉼표로 구분\n• 예시 문구는 사용하지 말고, 지정된 출력 형식만 고정 유지할 것\n\n② (신분 설정 및 외적 조건):\n• 사회적 지위, 소속, 경제 상황, 주거 상태 등 관계 형성에 영향을 주는 고정 정보 포함\n• 요약체 구문으로 서술\n\n③ (지속되는 관계 구조 전제):\n• 인물 간 관계의 구조적 위계나 지속적 통제 상태 등, 장기적으로 유지되는 상호 위치 관계를 포함\n• 감정선이나 일시적 상호작용이 아닌, 역할·위치·권력 관계 등 서사 전개 전반에 영향을 주는 구조 전제만 기술\n• 단순한 감정 표현이나 인물의 인식, 욕망 등은 포함하지 않으며, 구조 전제가 실질적으로 인물 간 제약이나 상호 반응 패턴에 영향을 주는 경우에 한해 포함\n• 설정 정보 항목에 포함되는 규칙, 명령, 조건 등은 이 항목에 중복 기록하지 않음\n\n④ (기억해야 할 설정 정보):\n• 인물의 발화, 명령, 행동으로 직접 확인 가능한 반복 조건, 명시적 제약, 신체 상태 등만 포함\n• 규칙은 외부에서 관찰 가능한 반복 지시 또는 제한 조건으로 한정하며, 요약체 구문으로 기술\n• 일시적 감정이나 내면 인식, 해석이 개입된 서술은 포함하지 않음\n• 임신, 부상, 복용 등 지속되는 신체 상태는 구체 시점과 함께 명시\n• 조건의 유효 여부가 불확실할 경우 생략하며, 변경이 발생한 경우 반드시 최신 상태로 갱신\n• 대화에 직접 언급되지 않더라도 변화가 없는 한 동일 항목을 반복 출력할 것\n\n⑤ (세계관 조건):\n• 감정선, 관계 구조, 설정 정보에 영향을 주는 사회적 전제, 계층 구조, 반복되는 배경 조건만 포함\n• 특정 인물에게만 적용되는 명령, 보고 의무, 접촉 제한 등은 ‘📌 기억해야 할 설정 정보’ 항목에 포함할 것\n• 세계관 조건은 모든 인물에게 반복 적용되는 구조 전제로 간주되며, 단일 사건 또는 일시적 상황은 포함하지 않음\n\n---\n\n# [요약]\n\n## 🕰️ 서사 진행 요약\n(줄거리 흐름을 요약체로 3~5줄 작성)\n\n## 🎯 감정 유발 사건 흐름\n• 인물명:\n　・요약체 구문\n　・요약체 구문\n• 인물명:\n　・요약체 구문\n　・요약체 구문\n\n## 🔄 관계 구조 변화\n• A→B: 지배 ↗\n• B→A: 신뢰 ↘\n- 관계 흐름: [A→B 요약 구문] / [B→A 요약 구문]\n\n## 📌 지속 기억 대상\n• 호칭 및 말투:\n　・A(→B): 호칭: XX / 말투: XX\n　・B(→A): 호칭: XX / 말투: XX\n• 신분 및 외적 조건:\n　・A: [요약체 구문]\n　・B: [요약체 구문]\n• 지속되는 관계 구조 전제: [요약체 구문]\n　・ [요약체 구문]\n• 기억해야 할 설정 정보: [요약체 구문]\n• 세계관 조건:\n\n---\n\n# 📢 출력 지침\n- 출력은 반드시 [요약] 섹션만 포함하며, 마크다운 코드블록(```markdown) 안에 작성한다.\n- 시퀀스(→) 구조 요약은 🕰️ 서사 진행 요약 및 🎯 감정 유발 사건 흐름 항목에서만 제한적으로 허용되며, 나머지 항목에서는 구조 기반 요약체를 고정 유지할 것.',
      },
    },
    "사용자 지정 프롬프트": {
      "사용자 지정 프롬프트": {
        description: "사용자 지정 프롬프트",
        prompt: undefined,
      },
    },
  };

  // Dark Red
  const TRAIT_DANGER = 0;
  // Red
  const TRAIT_BAD = 1;
  // Gray
  const TRAIT_CONSIDER = 2;
  // Blue
  const TRAIT_POSITIVE = 3;

  const MODEL_MAPPINGS = {
    Google: {
      // {0} = API Key
      // {1} = Model ID
      endpoint:
        "https://generativelanguage.googleapis.com/v1beta/models/{1}:generateContent?key={0}",
      requester: () => {},
      token: undefined,
      "Gemini 2.5 Flash Lite": {
        model: "gemini-2.5-flash-lite",
        description: "자유로운 고속 저비용 언어 모델.",
        hasFreeTier: true,
        maxInput: 1_048_756,
        pricingInput: 0.1,
        pricingOutput: 0.4,
        badge: {
          "무료 티어": TRAIT_POSITIVE,
          "약한 검열": TRAIT_POSITIVE,
          저성능: TRAIT_CONSIDER,
        },
      },
      "Gemini 2.5 Flash": {
        model: "gemini-2.5-flash",
        description: "자유로운 품질-비용 균형적 언어 모델.",
        hasFreeTier: true,
        maxInput: 1_048_756,
        pricingInput: 0.3,
        pricingOutput: 2.5,
        badge: {
          "무료 티어": TRAIT_POSITIVE,
          "약한 검열": TRAIT_POSITIVE,
          저성능: TRAIT_CONSIDER,
        },
      },
      "Gemini 2.5 Pro": {
        model: "gemini-2.5-pro",
        description: "자유로운 고성능 언어 모델.",
        hasFreeTier: true,
        max_input: 1_048_756,
        pricingInput: 10.0,
        pricingOutput: 15.0,
        badge: {
          "무료 티어": TRAIT_POSITIVE,
          고성능: TRAIT_POSITIVE,
          "약한 검열": TRAIT_POSITIVE,
          고비용: TRAIT_DANGER,
        },
      },
    },
    Anthropic: {
      // {0} = API Key
      // {1} = Model ID
      endpoint:
        "https://generativelanguage.googleapis.com/v1beta/models/{1}:generateContent?key={0}",
      requester: () => {},
      token: undefined,
      "Claude 4 Opus": {
        model: "claude-opus-4-0",
        description: "제약이 존재하는 고성능 언어 모델.",
        hasFreeTier: false,
        max_input: 200_000,
        pricingInput: 15.0,
        pricingOutput: 75.0,
        badge: {
          고성능: TRAIT_POSITIVE,
          "긍정 편향": TRAIT_CONSIDER,
          "유료 모델": TRAIT_DANGER,
          고비용: TRAIT_DANGER,
          "약한 검열": TRAIT_BAD,
        },
      },
      "Claude 4 Sonnet": {
        model: "claude-sonnet-4-0",
        description: "제약이 존재하는 효율적인 저비용 언어 모델.",
        hasFreeTier: false,
        max_input: 200_000,
        pricingInput: 3.0,
        pricingOutput: 15.0,
        badge: {
          "긍정 편향": TRAIT_CONSIDER,
          "유료 모델": TRAIT_DANGER,
          "약한 검열": TRAIT_BAD,
        },
      },
      "Claude 3.7 Sonnet": {
        model: "claude-3-7-sonnet-latest",
        description: "제약이 존재하는 고속 저비용 언어 모델.",
        hasFreeTier: false,
        max_input: 200_000,
        pricingInput: 3.0,
        pricingOutput: 15.0,
        badge: {
          "긍정 편향": TRAIT_CONSIDER,
          "유료 모델": TRAIT_DANGER,
          "약한 검열": TRAIT_BAD,
        },
      },
    },
    OpenAI: {
      // {0} = API Key
      // {1} = Model ID
      endpoint: "https://api.openai.com/v1/responses",
      requester: () => {},
      token: undefined,
      "ChatGPT 4.1": {
        model: "GPT-4.1",
        description: "강한 제약이 존재하는 고속 저비용 언어 모델.",
        hasFreeTier: false,
        max_input: 1_047_576,
        pricingInput: 2.0,
        pricingOutput: 8.0,
        badge: {
          "긍정 편향": TRAIT_CONSIDER,
          "유료 모델": TRAIT_DANGER,
          "약한 검열": TRAIT_BAD,
        },
      },
    },
  };
  const BRAND = "Chasm Crystallized";
  const PROJECT_NAME = "Ignitor";
  const VERSION = "v1.0.0";
  // =================================================
  //                       변수
  // =================================================
  const storedPrompts = {};

  let isLoaded = false;

  let doesStateChanged = false;

  let includeUserNote = false;

  let autoRetry = false;

  let selectedPromptName = "1:1 캐릭터";

  let selectedAuthor = "fastwrtn";

  let selectedPromptData = DEFAULT_PROMPTS.fastwrtn["1:1 캐릭터"];

  let isCustomPrompt = false;

  let selectedTokenProvider = "Google";

  let selectedModelProvider = "Google";

  let selectedModel = "Gemini 2.5 Flash Lite";

  let isCustomModel = false;

  let currentRequestMessage =
    "**OOC: 현재까지의 롤플레이 진행상황을 요약해줘.**";

  let summaryHeader =
    "**OOC: 현재까지의 롤플레이 진행상황 요약입니다. 아래 응답에 이 요약 내용을 참고하겠습니다.**";

  let summaryFooter = "";

  let customPrompt = "";

  // =================================================
  //                  노드 강제 편입
  // =================================================
  async function injectButton() {
    console.log("Ignitor - Appending");
    const selected = document.getElementsByClassName("burner-test-button");
    if (selected && selected.length > 0) {
      return;
    }
    // Top element
    const data = document.getElementsByClassName("css-2j5iyq");
    if (data && data.length > 0) {
      const top = data[0];
      const buttonCloned = top.childNodes[0].cloneNode(true);
      buttonCloned.className = "burner-test-button " + buttonCloned.className;
      const textNode = buttonCloned.getElementsByTagName("p");
      const imageNode = buttonCloned.getElementsByTagName("img");
      top.insertBefore(buttonCloned, top.childNodes[0]);
      textNode[0].innerText = "🔥  Chasm Ignitor";
      imageNode[0].remove();
      buttonCloned.removeAttribute("onClick");
      buttonCloned.addEventListener("click", async () => {
        await loadIgnitorPanel();
        await loadSettingPanel();
        await loadAllTokens();
        document.body.append(createTopDivision());
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
        appendLog("저장된 데이터를 불러왔습니다.");
      });
    }
  }
  // =================================================
  //                  노드 동적 생성
  // =================================================

  /**
   *
   * @returns {HTMLElement}
   */
  function createTopDivision() {
    if (document.getElementById("ignt-container")) {
      return;
    }

    const container = setupClassNode("div", "ignt-container", (node) => {
      node.id = "ignt-container";
    });
    const top = setupClassNode("div", "ignt-modal");
    top.append(createHeader());
    top.append(createSelectButton());
    top.append(createContentPanel());
    container.append(top);
    return container;
  }

  /**
   *
   * @returns {HTMLElement}
   */
  function createHeader() {
    const container = setupClassNode("div", "ignt-header", (node) => {
      node.id = "ignt-panel";
    });
    container.append(
      setupFullNode(
        "div",
        "ignt-logo",
        "width: fit-content; height: fit-content; margin-right: 5px;",
        (node) => {
          node.append(createFireIcon());
        }
      )
    );
    container.append(
      setupFullNode(
        "p",
        "ignt-title",
        "color: var(--chasm-ignt-text); font-weight: bold; margin-right: 3px;",
        (node) => {
          node.textContent = BRAND;
        }
      )
    );
    container.append(
      setupFullNode(
        "p",
        "ignt-title",
        "color: var(--chasm-ignt-primary); font-weight: bold; margin-right: 3px;",
        (node) => {
          node.textContent = PROJECT_NAME;
        }
      )
    );

    container.append(
      setupFullNode(
        "p",
        "ignt-badge ignt-version",
        "margin-left: 10px;",
        (node) => {
          node.textContent = VERSION;
        }
      )
    );
    container.append(
      setupFullNode(
        "div",
        "ignt-close",
        "margin-left: auto; width: 16px; height: 16px;",
        (node) => {
          node.append(createCloseIcon());
          node.onclick = () => {
            runCurrentCloseAction();
            document.getElementById("ignt-container").remove();
          };
        }
      )
    );
    return container;
  }

  /**
   *
   * @returns {HTMLElement}
   */
  function createSelectButton() {
    const top = setupFullNode(
      "div",
      "chasm-ignt-selector",
      "margin-top: 15px;"
    );
    top.append(
      setupClassNode("div", "chasm-ignt-panel-button", (button) => {
        button.setAttribute("selected", "true");
        button.append(
          setupStyleNode(
            "p",
            "width: 100%; height: fit-content; text-align: center; vertical-align: middle; line-height: 18px;",
            (node) => {
              node.textContent = "이그나이터";
            }
          )
        );
        button.onclick = () => {
          if (button.hasAttribute("selected")) {
            return;
          }
          runCurrentCloseAction();
          turnOffPanelButtons();
          button.setAttribute("selected", "true");
          for (let child of document.getElementById("chasm-ignt-content")
            .childNodes) {
            if (!child.classList.contains("chasm-ignt-hidden")) {
              child.classList.add("chasm-ignt-hidden");
            }
          }
          document
            .getElementById("chasm-ignt-ignitor-content")
            .classList.remove("chasm-ignt-hidden");
        };
      })
    );
    top.append(
      setupClassNode("div", "chasm-ignt-panel-button", (button) => {
        button.append(
          setupStyleNode(
            "p",
            "width: 100%; height: fit-content; text-align: center; vertical-align: middle; line-height: 18px;",
            (node) => {
              node.textContent = "설정";
            }
          )
        );
        button.onclick = () => {
          if (button.hasAttribute("selected")) {
            return;
          }
          runCurrentCloseAction();
          turnOffPanelButtons();
          button.setAttribute("selected", "true");

          for (let child of document.getElementById("chasm-ignt-content")
            .childNodes) {
            if (!child.classList.contains("chasm-ignt-hidden")) {
              child.classList.add("chasm-ignt-hidden");
            }
          }
          document
            .getElementById("chasm-ignt-setting")
            .classList.remove("chasm-ignt-hidden");
        };
      })
    );
    return top;
  }

  function turnOffPanelButtons() {
    for (let button of document.getElementsByClassName(
      "chasm-ignt-panel-button"
    )) {
      button.removeAttribute("selected");
    }
  }

  /**
   *
   * @returns {HTMLElement}
   */
  function createContentPanel() {
    const node = setupClassNode("div", "chasm-ignt-content", (node) => {
      node.id = "chasm-ignt-content";
    });
    node.append(createIgnitorContent());
    node.append(createSettingContent());
    return node;
  }

  /**
   *
   * @returns {HTMLElement}
   */
  function createIgnitorContent() {
    const container = setupClassNode(
      "div",
      "chasm-ignt-content-panel",
      (node) => {
        node.id = "chasm-ignt-ignitor-content";
      }
    );
    // container.classList.add("chasm-ignt-hidden");
    container.panelCloseAction = () => {
      if (doesStateChanged) {
        doesStateChanged = false;
        saveIgnitorPanel();
      }
    };

    const top = setupClassNode("div", "chasm-ignt-content-ignitor");
    top.append(
      createGridElement("채팅 범위", (node) => {
        node.append(
          setupClassNode("input", "", (input) => {
            input.id = "chasm-ignt-text-range";
            input.setAttribute("type", "range");
            input.setAttribute("min", "0");
            input.setAttribute("min", "50");
          })
        );
        node.append(
          setupFullNode(
            "div",
            "chasm-ignt-range-manual",
            "display: flex; flex-direction: row; margin-top: 10px; font-size: 13px;",
            (manual) => {
              manual.append(
                setupStyleNode(
                  "p",
                  "width: fit-content; height: fit-content; text-align: center; vertical-align: middle; color: var(--chasm-ignt-text-disabled);",
                  (node) => {
                    node.textContent = "최소: ";
                  }
                )
              );
              manual.append(
                setupFullNode(
                  "input",
                  "chasm-ignt-range-input",
                  "margin-left: 10px; width: 45px; height: 15px; background-color: var(--chasm-ignt-surface); color: var(--chasm-ignt-text); padding-left: 10px;",
                  (input) => {
                    input.setAttribute("type", "number");
                    input.value = 2;
                  }
                )
              );
              manual.append(
                setupStyleNode(
                  "p",
                  "width: fit-content; height: fit-content; text-align: center; margin-left: auto; vertical-align: middle; color: var(--chasm-ignt-text-disabled);",
                  (node) => {
                    node.textContent = "최대: ";
                  }
                )
              );
              manual.append(
                setupFullNode(
                  "input",
                  "chasm-ignt-range-input",
                  "margin-left: 10px; width: 45px; height: 15px; background-color: var(--chasm-ignt-surface); color: var(--chasm-ignt-text); padding-left: 10px;",
                  (input) => {
                    input.setAttribute("type", "number");
                    input.value = 2;
                  }
                )
              );
            }
          )
        );
      })
    );
    top.append(
      createGridElement("사전 정의 프롬프트", (node) => {
        const selectBox = createSelectBox(
          selectedPromptName,
          selectedPromptName
        );
        for (let author of Object.keys(DEFAULT_PROMPTS)) {
          selectBox.addGroup(author);
          for (let prompt of Object.keys(DEFAULT_PROMPTS[author])) {
            const element = selectBox.addOption(
              prompt,
              prompt,
              (id, selectedNode) => {
                const currentAuthor =
                  selectedNode.getAttribute("ignt-prompt-group");
                const currentName =
                  selectedNode.getAttribute("ignt-prompt-name");
                selectedPromptName = currentName;
                selectedPromptData =
                  DEFAULT_PROMPTS[currentAuthor][currentName];
                const prompt = selectedPromptData.prompt;
                if (prompt === undefined) {
                  isCustomPrompt = true;
                  document.getElementById("chasm-ignt-prompt").textContent = "";
                  document.getElementsByClassName(
                    "chasm-ignt-max-char"
                  )[0].textContent = `0자`;
                } else {
                  if (typeof prompt === "string") {
                    document.getElementById("chasm-ignt-prompt").textContent =
                      prompt;
                  } else {
                    document.getElementById("chasm-ignt-prompt").textContent =
                      JSON.stringify(prompt);
                  }
                  isCustomPrompt = false;
                  document.getElementsByClassName(
                    "chasm-ignt-max-char"
                  )[0].textContent = `${
                    document.getElementById("chasm-ignt-prompt").textContent
                      .length
                  }자`;
                }
              }
            );
            element.setAttribute("ignt-prompt-group", author);
            element.setAttribute("ignt-prompt-name", prompt);
          }
        }
        selectBox.appendTo(node);
      })
    );

    const promptNode = setupClassNode(
      "textarea",
      "chasm-ignt-text-box",
      (area) => {
        area.id = "chasm-ignt-prompt";
        const prompt = selectedPromptData.prompt;
        if (typeof prompt === "string") {
          area.textContent = prompt;
        } else {
          area.textContent = JSON.stringify(prompt);
        }
      }
    );

    top.append(
      createLongGridElement("프롬프트", (node, title) => {
        node.append(promptNode);
        title.append(
          setupStyleNode(
            "div",
            "display: flex; flex-direction: row; margin-left: auto; margin-botton: 10px; align-items: right;",
            (node) => {
              node.append(
                setupClassNode("div", "chasm-ignt-button", (node) => {
                  node.append(createLibraryIcon());
                  node.append(
                    setupParagraphNode("라이브러리", (node) => {
                      node.style.cssText = "margin-left: 5px";
                    })
                  );
                })
              );
              node.append(
                setupFullNode(
                  "div",
                  "chasm-ignt-button",
                  "margin-left: 15px;",
                  (node) => {
                    node.append(createPlusIcon());
                    node.append(
                      setupParagraphNode("저장", (node) => {
                        node.style.cssText = "margin-left: 5px";
                      })
                    );
                  }
                )
              );
            }
          )
        );
      })
    );

    const currentCharNode = setupClassNode(
      "p",
      "chasm-ignt-max-char",
      (node) => {
        node.textContent = promptNode.value.length + "자";
      }
    );
    top.append(
      createLongGridElement(undefined, (node) => {
        node.append(currentCharNode);
      })
    );

    if (promptNode.addEventListener) {
      promptNode.addEventListener(
        "input",
        function () {
          isCustomPrompt = false;
          doesStateChanged = true;
          customPrompt = promptNode.value;
          currentCharNode.textContent = promptNode.value.length + "자";
        },
        false
      );
    } else if (area.attachEvent) {
      promptNode.attachEvent("onpropertychange", function () {
        isCustomPrompt = false;
        doesStateChanged = true;
        customPrompt = promptNode.value;
        currentCharNode.textContent = promptNode.value.length + "자";
      });
    }

    top.append(
      createGridElement("모델 / 제공사", (node) => {
        const selectBox = createSelectBox(
          isCustomModel ? selectedModelProvider : selectedModel
        );

        for (let providers of Object.keys(MODEL_MAPPINGS)) {
          selectBox.addGroup(providers);
          for (let models of Object.keys(MODEL_MAPPINGS[providers])) {
            if (
              models === "endpoint" ||
              models === "requester" ||
              models === "token"
            )
              continue;
            const element = selectBox.addOption(
              models,
              models,
              (id, clickedNode) => {
                selectedModelProvider =
                  clickedNode.getAttribute("ignt-model-group");
                selectedModel = clickedNode.getAttribute("ignt-model-name");
                document
                  .getElementById("chasm-ignt-model")
                  .setAttribute("readonly", "readonly");
                document.getElementById("chasm-ignt-model").value = "";
                isCustomModel = false;
                doesStateChanged = true;
                return true;
              }
            );
            element.setAttribute("ignt-model-group", providers);
            element.setAttribute("ignt-model-name", models);
          }
        }
        selectBox.addGroup("모델 수동 입력");
        for (let providers of Object.keys(MODEL_MAPPINGS)) {
          const element = selectBox.addOption(
            providers,
            providers,
            (id, selectedNode) => {
              selectedModelProvider =
                selectedNode.getAttribute("ignt-model-group");
              selectedModel = selectedNode.getAttribute("ignt-model-name");
              document
                .getElementById("chasm-ignt-model")
                .removeAttribute("readonly");
              isCustomModel = true;
              return true;
            }
          );
          element.setAttribute("ignt-model-group", providers);
        }
        selectBox.appendTo(node);
      })
    );

    top.append(
      createGridElement("모델명", (node) => {
        node.append(
          setupClassNode("input", "chasm-ignt-text-field", (area) => {
            area.id = "chasm-ignt-model";
            area.setAttribute("type", "text");
            if (isCustomModel) {
              area.contentEditable = true;
              area.value = selectedModel;
            } else {
              area.contentEditable = false;
              area.setAttribute("readonly", "true");
            }
            area.onchange = () => {
              selectedModel = area.value;
              doesStateChanged = true;
            };
          })
        );
      })
    );

    top.append(
      createLongGridElement(undefined, (node) => {
        node.style.cssText = "flex-direction: row; align-items: left;";
        const userNoteelement = createCheckbox(
          "유저노트 첨부",
          includeUserNote,
          (value) => {
            doesStateChanged = true;
            includeUserNote = value;
          }
        );
        const autoRetryElement = createCheckbox(
          "자동 재시도",
          autoRetry,
          (value) => {
            doesStateChanged = true;
            autoRetry = value;
          }
        );
        autoRetryElement.style.cssText = "margin-left: 10px;";
        node.append(userNoteelement);
        node.append(autoRetryElement);
      })
    );

    top.append(
      createLongGridElement(undefined, (node) => {
        node.append(setupNode("hr"));
      })
    );
    top.append(
      createLongGridElement("실행 기록", (node) => {
        node.append(
          setupClassNode("code", "chasm-ignt-text-box", (area) => {
            area.id = "chasm-ignt-execute-log";
            area.contentEditable = false;
          })
        );
      })
    );

    top.append(
      createLongGridElement(undefined, (node) => {
        node.append(
          setupClassNode("div", "chasm-ignt-library", (node) => {
            node.append(
              setupClassNode("div", "chasm-ignt-library-header", (node) => {
                node.append(setupParagraphNode(""));
              })
            );
            for (let data of Object.keys(storedPrompts)) {
            }
          })
        );
      })
    );
    container.append(top);

    container.append(
      setupClassNode("button", "chasm-ignt-submit", (node) => {
        node.textContent = "시작";
      })
    );
    return container;
  }

  function createSettingContent() {
    const container = setupClassNode(
      "div",
      "chasm-ignt-content-panel",
      (node) => {
        node.id = "chasm-ignt-setting";
      }
    );

    container.panelCloseAction = () => {
      if (doesStateChanged) {
        const inputTokenField = document.getElementById("chasm-ignt-token");
        if (
          inputTokenField.value !== MODEL_MAPPINGS[selectedTokenProvider].token
        ) {
          if (inputTokenField.value.length > 0) {
            MODEL_MAPPINGS[selectedTokenProvider].token = inputTokenField.value;
          } else {
            MODEL_MAPPINGS[selectedTokenProvider].token = undefined;
          }
        }
        saveSettingPanel();
      }
    };

    container.classList.add("chasm-ignt-hidden");

    const top = setupClassNode("div", "chasm-ignt-content-ignitor");

    top.append(
      createGridElement("API 제공자", (node) => {
        const selectBox = createSelectBox(
          selectedTokenProvider,
          selectedTokenProvider
        );
        selectBox.addGroup("제공사");
        for (let providers of Object.keys(MODEL_MAPPINGS)) {
          const element = selectBox.addOption(
            providers,
            providers,
            (id, selectedNode) => {
              const currentProvider = selectBox.node.getAttribute(
                "chasm-ignt-token-provider"
              );
              const inputTokenField =
                document.getElementById("chasm-ignt-token");
              const inputToken = inputTokenField.value;
              console.log(inputToken);
              if (inputToken !== MODEL_MAPPINGS[currentProvider].token) {
                if (inputToken && inputToken.length > 0) {
                  MODEL_MAPPINGS[currentProvider].token = inputToken;
                } else {
                  MODEL_MAPPINGS[currentProvider].token = undefined;
                }
              }
              console.log("Current provider:" + currentProvider);
              selectBox.node.setAttribute("chasm-ignt-token-provider", id);
              console.log("Updated ID: " + id);
              console.log(MODEL_MAPPINGS[id].token);
              inputTokenField.value = MODEL_MAPPINGS[id].token ?? "";
              selectedTokenProvider = id;
              console.log("Value updated");
              return true;
            }
          );
          element.setAttribute("chasm-ignt-token-provider", providers);
        }
        selectBox.node.setAttribute(
          "chasm-ignt-token-provider",
          selectedTokenProvider
        );
        selectBox.appendTo(node);
      })
    );

    top.append(
      createGridElement("토큰", (node) => {
        node.append(
          setupClassNode("input", "chasm-ignt-text-field", (area) => {
            area.id = "chasm-ignt-token";
            area.setAttribute("type", "password");
            area.contentEditable = true;
            console.log("Selected token: " + selectedTokenProvider);

            if (MODEL_MAPPINGS[selectedTokenProvider].token) {
              area.value = MODEL_MAPPINGS[selectedTokenProvider].token;
            }
            area.onchange = (event) => {
              doesStateChanged = true;
            };
          })
        );
      })
    );
    top.append(
      createLongGridElement("프롬프트 요약 요청 메시지", (node) => {
        node.append(
          setupClassNode("input", "chasm-ignt-text-field", (area) => {
            area.id = "chasm-ignt-request-message";
            area.setAttribute("type", "text");
            area.contentEditable = true;
            area.value = currentRequestMessage;
            area.onchange = (event) => {
              doesStateChanged = true;
            };
          })
        );
      })
    );

    top.append(
      createLongGridElement("요약본 머릿말", (node) => {
        node.append(
          setupClassNode("input", "chasm-ignt-text-field", (area) => {
            area.id = "chasm-ignt-header";
            area.setAttribute("type", "text");
            area.value = summaryHeader;
            area.contentEditable = true;
            area.onchange = (event) => {
              doesStateChanged = true;
            };
          })
        );
      })
    );

    top.append(
      createLongGridElement("요약본 꼬리말", (node) => {
        node.append(
          setupClassNode("input", "chasm-ignt-text-field", (area) => {
            area.id = "chasm-ignt-footer";
            area.setAttribute("type", "text");
            area.value = summaryFooter;
            area.contentEditable = true;
            area.onchange = (event) => {
              doesStateChanged = true;
            };
          })
        );
      })
    );

    container.append(top);

    return container;
  }
  function createOuterClickDetection(lambda) {
    return setupClassNode("div", "chasm-ignt-outer-click-detection", (node) => {
      node.id = "chasm-ignt-outer-click-detection";
      node.onclick = lambda;
    });
  }

  function removeOuterClickDetection() {
    const node = document.getElementById("chasm-ignt-outer-click-detection");
    if (node) node.remove();
  }

  function hasOuterClickDetection() {
    if (document.getElementById("chasm-ignt-outer-click-detection")) {
      return true;
    }
    return false;
  }

  function triggerOuterClickDetection() {
    const node = document.getElementById("chasm-ignt-outer-click-detection");
    if (node) {
      node.onclick();
    }
  }

  function appendLog(log) {
    const element = document.getElementById("chasm-ignt-execute-log");
    if (element) {
      const time = new Date();
      element.innerHTML =
        element.innerHTML +
        "<br/>" +
        "<span color = 'gray'>" +
        `[${time.getHours().toString().padStart(2, "0")}:${time
          .getMinutes()
          .toString()
          .padStart(2, "0")}:${time
          .getSeconds()
          .toString()
          .padStart(2, "0")}]` +
        `</span> <span>${log}</span>`;
      element.scrollTop = element.scrollHeight;
    }
  }
  // =================================================
  //                 노드 생성 유틸리티
  // =================================================
  /**
   * 파라미터를 기준으로 클래스가 적용된 새 HTML 단락 요소를 만들어 반환합니다.
   * @param {string} text 옵션 텍스트
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupParagraphNode(text, setupLambda) {
    const node = document.createElement("p");
    node.textContent = text;
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   * 파라미터를 기준으로 클래스가 적용된 새 HTML 옵션 요소를 만들어 반환합니다.
   * @param {string} text 옵션 텍스트
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupOptionNode(text, setupLambda) {
    const node = document.createElement("option");
    node.textContent = text;
    if (cls) {
      node.className = cls;
    }
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   * 파라미터를 기준으로 클래스가 적용된 새 HTML 옵션 요소를 만들어 반환합니다.
   * @param {string} text 옵션 텍스트
   * @param {string|undefined} cls 클래스
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupClassOptionNode(text, cls, setupLambda) {
    const node = document.createElement("li");
    node.textContent = text;
    if (cls) {
      node.className = cls;
    }
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   * 파라미터를 기준으로 클래스가 적용된 새 HTML 옵션 요소를 만들어 반환합니다.
   * @param {string} text 옵션 텍스트
   * @param {string|undefined} cls 클래스
   * @param {string|undefined} style 인라인 스타일
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupFullOptionNode(text, cls, style, setupLambda) {
    const node = document.createElement("option");
    node.textContent = text;
    if (cls) {
      node.className = cls;
    }
    if (style) {
      node.style.cssText = style;
    }
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   * 파라미터를 기준으로 새 HTML 요소를 만들어 반환합니다.
   * @param {string} name 태그 이름 (div, p..)
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupNode(name, setupLambda) {
    const node = document.createElement(name);
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   * 파라미터를 기준으로 클래스가 적용된 새 HTML 요소를 만들어 반환합니다.
   * @param {string} name 태그 이름 (div, p..)
   * @param {string|undefined} cls 클래스
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupClassNode(name, cls, setupLambda) {
    const node = document.createElement(name);
    if (cls) {
      node.className = cls;
    }
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   * 파라미터를 기준으로 인라인 스타일이 적용된 새 HTML 요소를 만들어 반환합니다.
   * @param {string} name 태그 이름 (div, p..)
   * @param {string|undefined} style 인라인 스타일
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupStyleNode(name, style, setupLambda) {
    const node = document.createElement(name);
    if (style) {
      node.style.cssText = style;
    }
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   * 파라미터를 기준으로 클래스와 인라인 스타일이 적용된 새 HTML 요소를 만들어 반환합니다.
   * @param {string} name 태그 이름 (div, p..)
   * @param {string|undefined} cls 클래스
   * @param {string|undefined} style 인라인 스타일
   * @param {((node: HTMLElement) => any) | undefined} setupLambda 노드 초기화 람다
   * @returns {HTMLElement} 생성된 HTML 요소
   */
  function setupFullNode(name, cls, style, setupLambda) {
    const node = document.createElement(name);
    if (cls) {
      node.className = cls;
    }
    if (style) {
      node.style.cssText = style;
    }
    if (setupLambda) {
      setupLambda(node);
    }
    return node;
  }

  /**
   *
   * @param {string} titleText
   * @param {((node: HTMLElement, title: HTMLElement | undefined) => any) | undefined} lambda
   */
  function createGridElement(titleText, lambda) {
    return setupClassNode("div", "chasm-ignt-grid-element", (node) => {
      if (titleText) {
        const title = setupClassNode(
          "div",
          "chasm-ignt-element-title",
          (elementTitle) => {
            elementTitle.append(
              setupNode("p", (node) => {
                node.textContent = titleText;
              })
            );
          }
        );
        node.append(title);
        lambda(node, title);
      } else {
        lambda(node, undefined);
      }
    });
  }

  /**
   *
   * @param {string | undefined} titleText
   * @param {((node: HTMLElement, title: HTMLElement | undefined) => any) | undefined} lambda
   */
  function createLongGridElement(titleText, lambda) {
    return setupClassNode("div", "chasm-ignt-grid-element-long", (node) => {
      if (titleText) {
        const title = setupClassNode(
          "div",
          "chasm-ignt-element-title",
          (elementTitle) => {
            elementTitle.append(
              setupNode("p", (node) => {
                node.textContent = titleText;
              })
            );
          }
        );
        node.append(title);
        if (lambda) {
          lambda(node, title);
        }
      } else {
        if (lambda) {
          lambda(node, undefined);
        }
      }
    });
  }
  // =================================================
  //                      SVG
  // =================================================
  function createCloseIcon() {
    return setupStyleNode("div", "width: 32px; height: 32px;", (node) => {
      // https://www.svgrepo.com/svg/522506/close
      node.innerHTML =
        '<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools --><svg width="16px" height="16px" viewBox="-0.5 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 21.32L21 3.32001" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 3.32001L21 21.32" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
    });
  }

  function createFireIcon() {
    // https://www.svgrepo.com/svg/500378/fire
    return setupStyleNode("div", "width: 24px; height: 24px;", (node) => {
      node.innerHTML =
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Uploaded to: SVG Repo, www.svgrepo.com, Transformed by: SVG Repo Mixer Tools --><svg fill="#FFFFFF" width="24px" height="24px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" stroke="#FFFFFF"><g id="SVGRepo_bgCarrier" stroke-width="0"/><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"/><g id="SVGRepo_iconCarrier"><path d="M9.32 15.653a.812.812 0 0 1-.086-.855c.176-.342.245-.733.2-1.118a2.106 2.106 0 0 0-.267-.779 2.027 2.027 0 0 0-.541-.606 3.96 3.96 0 0 1-1.481-2.282c-1.708 2.239-1.053 3.51-.235 4.63a.748.748 0 0 1-.014.901.87.87 0 0 1-.394.283.838.838 0 0 1-.478.023c-1.105-.27-2.145-.784-2.85-1.603a4.686 4.686 0 0 1-.906-1.555 4.811 4.811 0 0 1-.263-1.797s-.133-2.463 2.837-4.876c0 0 3.51-2.978 2.292-5.18a.621.621 0 0 1 .112-.653.558.558 0 0 1 .623-.147l.146.058a7.63 7.63 0 0 1 2.96 3.5c.58 1.413.576 3.06.184 4.527.325-.292.596-.641.801-1.033l.029-.064c.198-.477.821-.325 1.055-.013.086.137 2.292 3.343 1.107 6.048a5.516 5.516 0 0 1-1.84 2.027 6.127 6.127 0 0 1-2.138.893.834.834 0 0 1-.472-.038.867.867 0 0 1-.381-.29zM7.554 7.892a.422.422 0 0 1 .55.146c.04.059.066.126.075.198l.045.349c.02.511.014 1.045.213 1.536.206.504.526.95.932 1.298a3.06 3.06 0 0 1 1.16 1.422c.22.564.25 1.19.084 1.773a4.123 4.123 0 0 0 1.39-.757l.103-.084c.336-.277.613-.623.813-1.017.201-.393.322-.825.354-1.269.065-1.025-.284-2.054-.827-2.972-.248.36-.59.639-.985.804-.247.105-.509.17-.776.19a.792.792 0 0 1-.439-.1.832.832 0 0 1-.321-.328.825.825 0 0 1-.035-.729c.412-.972.54-2.05.365-3.097a5.874 5.874 0 0 0-1.642-3.16c-.156 2.205-2.417 4.258-2.881 4.7a3.537 3.537 0 0 1-.224.194c-2.426 1.965-2.26 3.755-2.26 3.834a3.678 3.678 0 0 0 .459 2.043c.365.645.89 1.177 1.52 1.54C4.5 12.808 4.5 10.89 7.183 8.14l.372-.25z"/></g></svg>';
    });
  }

  function createArrowIcon() {
    // https://www.svgrepo.com/svg/521469/arrow-down
    return setupStyleNode("div", "width: 24px; height: 24px;", (node) => {
      node.innerHTML =
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Uploaded to: SVG Repo, www.svgrepo.com, Transformed by: SVG Repo Mixer Tools --><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="#FFFFFF"><g id="SVGRepo_bgCarrier" stroke-width="0"/><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"/><g id="SVGRepo_iconCarrier"> <path d="M5.70711 9.71069C5.31658 10.1012 5.31658 10.7344 5.70711 11.1249L10.5993 16.0123C11.3805 16.7927 12.6463 16.7924 13.4271 16.0117L18.3174 11.1213C18.708 10.7308 18.708 10.0976 18.3174 9.70708C17.9269 9.31655 17.2937 9.31655 16.9032 9.70708L12.7176 13.8927C12.3271 14.2833 11.6939 14.2832 11.3034 13.8927L7.12132 9.71069C6.7308 9.32016 6.09763 9.32016 5.70711 9.71069Z" fill="#FFFFFF"/> </g></svg>';
    });
  }

  function createPlusIcon() {
    return setupStyleNode("div", "width: 16px; height: 16px;", (node) => {
      // https://www.svgrepo.com/svg/532994/plus
      node.innerHTML =
        '<svg width="16px" height="16px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="#FFFFFF"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M6 12H18M12 6V18" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>';
    });
  }

  function createLibraryIcon() {
    return setupStyleNode("div", "width: 16px; height: 16px;", (node) => {
      // https://www.svgrepo.com/svg/486715/library
      node.innerHTML =
        '<svg width="16px" height="16px" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#FFFFFF" stroke="#FFFFFF"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <title>library</title> <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="Combined-Shape" fill="#FFFFFF" transform="translate(42.666667, 85.333333)"> <path d="M3.55271368e-14,298.666667 L426.666667,298.666667 L426.666667,341.333333 L3.55271368e-14,341.333333 L3.55271368e-14,298.666667 Z M42.6666667,1.42108547e-14 L106.666667,1.42108547e-14 L106.666667,277.333333 L42.6666667,277.333333 L42.6666667,1.42108547e-14 Z M128,21.3333333 L192,21.3333333 L192,277.333333 L128,277.333333 L128,21.3333333 Z M288.933802,36.9522088 L351.961498,25.8387255 L399.909944,277.333333 L330.641827,277.70319 L288.933802,36.9522088 Z M213.333333,21.3333333 L277.333333,21.3333333 L277.333333,277.333333 L213.333333,277.333333 L213.333333,21.3333333 Z"> </path> </g> </g> </g></svg>';
    });
  }

  // =================================================
  //                   데이터 IO
  // =================================================
  async function saveIgnitorPanel() {
    const data = {
      provider: selectedModelProvider,
      model: selectedModel,
      isCustomModel: isCustomModel,
      includeUserNote: includeUserNote,
      autoRetry: autoRetry,
      summaryHeader: summaryHeader,
      summaryFooter: summaryFooter,
      customPrompt: customPrompt,
      isCustomPrompt: false,
      prompt: "",
    };
    if (isCustomPrompt) {
      data.isCustomPrompt = true;
      data.prompt = selectedPromptName;
    } else {
      data.isCustomPrompt = false;
      data.promptAuthor = selectedAuthor;
      data.prompt = selectedPromptName;
    }
    localStorage.setItem("ignitor-main-state", JSON.stringify(data));
  }

  async function loadIgnitorPanel() {
    const dataString = localStorage.getItem("ignitor-main-state");
    if (dataString) {
      const data = JSON.parse(dataString);
      selectedModelProvider = data.provider;
      selectedModel = data.model;
      includeUserNote = data.includeUserNote ?? false;
      autoRetry = data.autoRetry ?? false;
      summaryHeader = data.summaryHeader ?? "";
      summaryFooter = data.summaryFooter ?? "";
      isCustomPrompt = data.isCustomPrompt ?? false;
      selectedPromptName = data.prompt;
      selectedAuthor = data.selectedAuthor;
      isCustomModel = data.isCustomModel ?? false;
    }
  }

  async function saveCustomPrompts() {
    localStorage.setItem(
      "ignitor-custom-prompts",
      JSON.stringify(storedPrompts)
    );
  }

  async function saveSettingPanel() {
    const data = {
      currentRequestMessage: currentRequestMessage,
      summaryHeader: summaryHeader,
      summaryFooter: summaryFooter,
    };
    localStorage.setItem("ignitor-setting-state", JSON.stringify(data));
    await saveAllTokens();
  }

  async function loadSettingPanel() {
    const dataString = localStorage.getItem("ignitor-setting-state");
    if (dataString) {
      const data = JSON.parse(dataString);
      currentRequestMessage = data.currentRequestMessage;
      summaryHeader = data.summaryHeader;
      summaryFooter = data.summaryFooter;
    }
  }

  async function saveAllTokens() {
    const tokens = {};
    for (let key of Object.keys(MODEL_MAPPINGS)) {
      console.log("Scanning for " + key);
      console.log(MODEL_MAPPINGS[key].token);
      if (MODEL_MAPPINGS[key].token) {
        tokens[key] = {
          type: "raw",
          token: MODEL_MAPPINGS[key].token,
        };
      }
    }
    localStorage.setItem("ignitor-saved-tokens", JSON.stringify(tokens));
  }

  async function loadAllTokens() {
    const dataString = localStorage.getItem("ignitor-saved-tokens");
    if (dataString) {
      console.log("Data string: " + dataString);
      const tokens = JSON.parse(dataString);
      for (let key of Object.keys(MODEL_MAPPINGS)) {
        console.log("Scanning " + key);
        if (tokens[key]) {
          console.log("Loaded " + key + "(" + tokens[key] + ")");
          const currentToken = tokens[key];
          if (currentToken.type === "raw") {
            MODEL_MAPPINGS[key].token = currentToken.token;
          } else {
            logError(
              `Unexpected token type '${currentToken.type}' from provider ${key}`
            );
          }
        }
      }
    }
  }

  function runCurrentCloseAction() {
    for (let child of document.getElementById("chasm-ignt-content")
      .childNodes) {
      if (!child.classList.contains("chasm-ignt-hidden")) {
        child.panelCloseAction();
      }
    }
  }
  // =================================================
  //                 커스텀 셀렉트 구현
  // =================================================
  /**
   *
   * @returns 노드 수정 인스턴스
   */
  function createSelectBox(initialText, initialId) {
    let topNode = setupClassNode("ul", "chasm-ignt-select");
    let optionContainer = setupClassNode("div", "chasm-ignt-list");
    topNode.setAttribute("chasm-ignt-selected", initialId);
    const title = setupFullNode(
      "div",
      "chasm-ignt-option",
      "width: 100%; display: flex; flex-direction: row; align-items: center;",
      (option) => {
        option.append(
          setupStyleNode("span", "height: fit-content;", (textNode) => {
            textNode.textContent = initialText;
          })
        );
        option.append(
          setupStyleNode("div", "margin-left: auto;", (iconNode) => {
            iconNode.append(createArrowIcon());
          })
        );
        option.onclick = () => {
          if (hasOuterClickDetection()) {
            triggerOuterClickDetection();
            return;
          }
          if (topNode.hasAttribute("list-enabled")) {
            topNode.removeAttribute("list-enabled");
          } else {
            topNode.setAttribute("list-enabled", "true");
            optionContainer.style.cssText = `top: ${
              topNode.getBoundingClientRect().top + topNode.clientHeight
            }px;`;
            document.getElementById("chasm-ignt-content").append(
              createOuterClickDetection(() => {
                topNode.removeAttribute("list-enabled");
                removeOuterClickDetection();
              })
            );
          }
        };
      }
    );
    topNode.append(title);
    topNode.append(optionContainer);

    return {
      node: topNode,
      /**
       *
       * @param {string} text
       * @param {string} id
       * @param {((selectedId: string, node: HTMLElement) => boolean) | undefined} onclick
       */
      addOption: (text, id, onclick) => {
        const element = setupClassNode("div", "chasm-ignt-option", (option) => {
          option.textContent = text;
          option.setAttribute("chasm-ignt-option-text", text);
          option.setAttribute("chasm-ignt-option-id", id);
          option.onclick = () => {
            removeOuterClickDetection();
            topNode.removeAttribute("list-enabled");
            const selectedId = option.getAttribute("chasm-ignt-option-id");
            if (onclick(selectedId, option)) {
              topNode.setAttribute("chasm-ignt-selected", selectedId);
              title.childNodes[0].textContent = option.getAttribute(
                "chasm-ignt-option-text"
              );
            }
          };
        });
        optionContainer.append(element);
        return element;
      },
      /**
       *
       * @param {HTMLElement} node
       */
      appendTo: (node) => {
        node.append(topNode);
      },
      addGroup: (text) => {
        optionContainer.append(
          setupClassNode("div", "chasm-ignt-option-group", (group) => {
            group.innerText = text;
          })
        );
      },
    };
  }
  // =================================================
  //                  체크박스 구현
  // =================================================
  function toggleCustomCheckbox(element) {
    if (element.hasAttribute("checked")) {
      element.removeAttribute("checked");
    } else {
      element.setAttribute("checked", "true");
    }
  }

  function isCustomCheckboxChecked(element) {
    return element.getAttribute("checked") === "true";
  }

  /**
   * 새 체크박스 필드를 생성합니다.
   * @param {string} text 체크박스 텍스트
   * @param {boolean} isChecked 체크 여부
   * @param {(checked: boolean, node: HTMLElement) => void} lambda 값 변경시 실행될 람다
   */
  function createCheckbox(text, isChecked, observer) {
    return setupClassNode("div", "chasm-ignt-checkbox", (node) => {
      node.append(
        setupClassNode("div", "checkbox-icon-container", (container) => {
          container.append(setupClassNode("img", "checkbox-icon"));
        })
      );
      node.append(
        setupClassNode("span", "checkbox-text", (node) => {
          node.textContent = text;
        })
      );
      if (isChecked) {
        toggleCustomCheckbox(node);
      }
      node.onclick = () => {
        toggleCustomCheckbox(node);
        if (observer) {
          observer(isCustomCheckboxChecked(node), node);
        }
      };
    });
  }
  // =================================================
  //                유틸리티성 메서드
  // =================================================
  /**
   * 대상 노드의 필드에서 리액트 속성(React Property)를 찾아 람다에 파라미터로 전달합니다.
   * @param {Node} node 리액트 속성을 찾을 대상 노드
   * @param {(property: any) => void} lambda 만약 리액트 속성이 존재한다면 실행될 람다
   * @returns {any | undefined} 람다의 결과값 혹은 undefined
   */
  function findReactProperty(node, lambda) {
    for (let key of Object.keys(node)) {
      if (key.startsWith("__reactProps")) {
        return lambda(node[key]);
      }
    }
    return undefined;
  }
  /**
   * 크랙 페이지의 테마가 다크 모드인지 확인합니다.
   * @returns {boolean} 다크 모드 여부
   */
  function isDarkMode() {
    return document.body.getAttribute("data-theme") === "dark";
  }
  /**
   * 쿠키에서 액세스 토큰을 추출해 반환합니다.
   * @returns { string | undefined } 액세스 토큰
   */
  function extractAccessToken() {
    const cookies = document.cookie.split(";");
    for (let cookie of cookies) {
      const [key, value] = cookie.trim().split("=");
      if (key === "access_token") return value;
    }
    return undefined;
  }
  /**
   * 지정한 노드 혹은 요소에 변경 옵저버를 등록합니다.
   * @param {HTMLElement} observeTarget 변경 감지 대상
   * @param {() => any} lambda 실행할 람다
   */
  function attachObserver(observeTarget, lambda) {
    const Observer = window.MutationObserver || window.WebKitMutationObserver;
    if (observeTarget && Observer) {
      let instance = new Observer(lambda);
      instance.observe(observeTarget, {
        childList: true,
        subtree: true,
        attributes: true,
      });
    }
  }
  /**
   * 지정한 노드 혹은 요소에 URL 변동 감지성 변경 옵저버를 등록합니다.
   * 이 펑션으로 등록된 옵저버는 이전과 현재 URL이 다를때만 작동합니다.
   * @param {boolean} runIfFirst 첫 초기화시 작동 여부
   * @param {HTMLElement} node 변경 감지 대상
   * @param {() => any} lambda 실행할 람다
   */
  function attachHrefObserver(node, lambda) {
    let oldHref = location.href;
    attachObserver(node, () => {
      if (oldHref !== location.href) {
        oldHref = location.href;
        lambda();
      }
    });
  }
  /**
   * 콘솔에 지정한 포맷으로 디버그를 출력합니다.
   * @param {string} message 출력할 메시지
   */
  function log(message) {
    console.log(
      "%cChasm Crystallized Ignitor: %cInfo: %c" + message,
      "color: cyan;",
      "color: blue;",
      "color: inherit;"
    );
  }
  /**
   * 콘솔에 지정한 포맷으로 경고를 출력합니다.
   * @param {string} message 출력할 메시지
   */
  function logWarning(message) {
    console.log(
      "%cChasm Crystallized Ignitor: %cWarning: %c" + message,
      "color: cyan;",
      "color: yellow;",
      "color: inherit;"
    );
  }
  /**
   * 콘솔에 지정한 포맷으로 오류를 출력합니다.
   * @param {string} message 출력할 메시지
   */
  function logError(message) {
    console.log(
      "%cChasm Crystallized Ignitor: %cError: %c" + message,
      "color: cyan;",
      "color: red;",
      "color: inherit;"
    );
  }

  // =================================================
  //                  스크립트 초기화
  // =================================================
  function prepare() {
    setup();
    attachHrefObserver(document, () => {
      elementSize = 0;
      filteredElements = [];
    });
    attachObserver(document, () => {
      setup();
    });
  }
  function setup() {
    if (!/\/u\/[a-f0-9]+\/c\/[a-f0-9]+/.test(location.pathname)) return;
    injectButton();
  }
  // =================================================
  //               스크립트 초기 실행
  // =================================================
  "loading" === document.readyState
    ? document.addEventListener("DOMContentLoaded", prepare)
    : prepare(),
    window.addEventListener("load", prepare);
})();
